

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tridiagonal Solvers &mdash; Omega develop documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
      <script src="../_static/jquery.js"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/doctools.js"></script>
      <script src="../_static/sphinx_highlight.js"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Omega V0: Shallow Water" href="../design/OmegaV0ShallowWater.html" />
    <link rel="prev" title="Tracers" href="Tracers.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Omega
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/QuickStart.html">Quick Start for Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OmegaBuild.html">CMake-based Omega Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Logging.html">Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Dimension.html">Dimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Error.html">Error handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Field.html">Fields and Metadata (Field)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IOStreams.html">IO Streams (IOStream)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/AuxiliaryState.html">Auxiliary State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OceanState.html">Ocean State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TimeStepping.html">Time stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Tracers.html">Tracers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TridiagonalSolvers.html">Tridiagonal Solvers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer's guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="QuickStart.html">Quick Start for Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="CondaEnv.html">Development Conda Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="Linting.html">Linting Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildDocs.html">Building the Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html#arrays-and-kokkos">Arrays and Kokkos</a></li>
<li class="toctree-l1"><a class="reference internal" href="MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="CMakeBuild.html">Omega Build with CMake</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logging.html">Developing Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dimension.html">Dimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="Error.html">Error Handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="Field.html">Fields and Metadata (Field)</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="IOStreams.html">IO Streams (IOStream)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="AuxiliaryState.html">Auxiliary State</a></li>
<li class="toctree-l1"><a class="reference internal" href="TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="OceanState.html">Ocean State</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepping.html">Time stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tracers.html">Tracers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tridiagonal Solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#representations-of-tridiagonal-systems">Representations of tridiagonal systems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-tridiagonal-system">General tridiagonal system</a></li>
<li class="toctree-l3"><a class="reference internal" href="#diffusion-type-tridiagonal-system">Diffusion-type tridiagonal system</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-tridiagonal-solvers">Using tridiagonal solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#top-level-method">Top-level method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#team-level-method">Team-level method</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../design/OmegaV0ShallowWater.html">Omega V0: Shallow Water</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Broadcast.html">Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Config.html">Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/DataTypes.html">DataTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Decomp.html">Decomp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Driver.html">Driver and Component Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Error.html">ErrorHandler (Error)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Halo.html">Halo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/HorzMeshClass.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/MachEnv.html">MachineEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/IO.html">Input/Output (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/IOStreams.html">IOStreams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/State.html">State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Tendency.html">Tendency</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/AuxiliaryVariables.html">Auxiliary variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/AuxiliaryState.html">AuxiliaryState</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/TimeMgr.html">TimeManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Timers.html">Timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/TimeStepping.html">Time Stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Tracers.html">Tracer Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/TridiagonalSolver.html">Tridiagonal Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/VerticalMixingCoeff.html">Vertical Mixing Coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design/Template.html">Template</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Omega</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tridiagonal Solvers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/devGuide/TridiagonalSolvers.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="tridiagonal-solvers">
<span id="omega-dev-tridiagonal"></span><h1>Tridiagonal Solvers<a class="headerlink" href="#tridiagonal-solvers" title="Permalink to this heading"></a></h1>
<p>Omega provides batched solvers for tridiagonal systems of equations.
Here, batched means that many systems of the same size need to be solved at the same time.
Typically, this is because one system needs to be solved per ocean column.
In addition to providing solvers for general tridiagonal systems,
specialized solvers for diffusion-type systems with better stability
properties are available.
To obtain portable performance, different solution algorithms are utilized
on CPUs and GPUs.
The solvers implement the same user interface for CPUs and GPUs, so users
should be able to ignore which algorithm is used.
Two type aliases are provided that resolve to the optimal solver for a given
architecture:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TriDiagSolver</span></code> for general systems</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TriDiagDiffSolver</span></code> for diffusion-type systems</p></li>
</ul>
<section id="representations-of-tridiagonal-systems">
<h2>Representations of tridiagonal systems<a class="headerlink" href="#representations-of-tridiagonal-systems" title="Permalink to this heading"></a></h2>
<section id="general-tridiagonal-system">
<h3>General tridiagonal system<a class="headerlink" href="#general-tridiagonal-system" title="Permalink to this heading"></a></h3>
<p>A general tridiagonal system is represented by three vectors
<code class="docutils literal notranslate"><span class="pre">DL</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">DU</span></code>, representing the lower, main, and upper diagonal, respectively, and a right-hand-side vector <code class="docutils literal notranslate"><span class="pre">X</span></code>
<div class="math notranslate nohighlight">
\[
(DL)_i Y_{i - 1} + D_i Y_i + (DU)_i Y_{i + 1} = X_i.
\]</div>
</p>
</section>
<section id="diffusion-type-tridiagonal-system">
<h3>Diffusion-type tridiagonal system<a class="headerlink" href="#diffusion-type-tridiagonal-system" title="Permalink to this heading"></a></h3>
<p>A diffusion-type system is represented by two vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code>, and a right-hand-side vector <code class="docutils literal notranslate"><span class="pre">X</span></code>. It has the form
<div class="math notranslate nohighlight">
\[
-G_{i - 1} Y_{i - 1} + (G_{i - 1} + G_i + H_i) Y_i - G_{i} Y_{i + 1} = X_i.
\]</div>
</p>
</section>
</section>
<section id="using-tridiagonal-solvers">
<h2>Using tridiagonal solvers<a class="headerlink" href="#using-tridiagonal-solvers" title="Permalink to this heading"></a></h2>
<p>There are two main ways to use Omega batched tridiagonal solvers:</p>
<ul class="simple">
<li><p>Create global arrays storing the coefficients of all systems and call the top-level <code class="docutils literal notranslate"><span class="pre">solve</span></code> method</p></li>
<li><p>Use a team-level solver inside a parallel loop using Kokkos team policy</p></li>
</ul>
<p>While the first method is simpler, for computational performance it is better to use
the second method. This is because the second method allows one to define a system, solve it,
and do some post-processing of the solution in one parallel loop.
With the first method this would require multiple parallel loops, and allocation of storage
for the coefficients of all systems, which are typically no longer needed after the solution is obtained.</p>
<section id="top-level-method">
<h3>Top-level method<a class="headerlink" href="#top-level-method" title="Permalink to this heading"></a></h3>
<p>To solve <code class="docutils literal notranslate"><span class="pre">NBatch</span></code> systems of size <code class="docutils literal notranslate"><span class="pre">NRow</span></code> using the general solver
four arrays <code class="docutils literal notranslate"><span class="pre">DL</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">DU</span></code>, and <code class="docutils literal notranslate"><span class="pre">X</span></code> need to be defined.
All arrays are of size (<code class="docutils literal notranslate"><span class="pre">NBatch</span></code>, <code class="docutils literal notranslate"><span class="pre">NRow</span></code>) and contain the
coefficients for each of the systems.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Array2DReal</span><span class="w"> </span><span class="n">DL</span><span class="p">(</span><span class="s">&quot;DL&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span><span class="w"> </span><span class="c1">// DL(n, :) = lower diagonal of system n</span>
<span class="n">Array2DReal</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span><span class="w">   </span><span class="c1">// D(n, :)  = main diagonal of system n</span>
<span class="n">Array2DReal</span><span class="w"> </span><span class="n">DU</span><span class="p">(</span><span class="s">&quot;DU&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span><span class="w"> </span><span class="c1">// DU(n, :) = upper diagonal of system n</span>
<span class="n">Array2DReal</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span><span class="w">   </span><span class="c1">// X(n, :)  = rhs of system n</span>
</pre></div>
</div>
<p>Once these arrays are filled with the coefficients, to solve the systems the
static <code class="docutils literal notranslate"><span class="pre">TriDiagSolver:solve</span></code> method is called</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TriDiagSolver</span><span class="p">::</span><span class="n">solve</span><span class="p">(</span><span class="n">DL</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">DU</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
</pre></div>
</div>
<p>After this call, the rhs array <code class="docutils literal notranslate"><span class="pre">X</span></code> contains the solution.</p>
<p>Solving diffusion-type systems is similar, except the input arrays contain coefficients in the
form presented <a class="reference internal" href="#diffusion-type-tridiagonal-system">above</a>
and the static <code class="docutils literal notranslate"><span class="pre">TriDiagDiffSolver::solve</span></code> method is called</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Array2DReal</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="s">&quot;G&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span><span class="w"> </span><span class="c1">// G(n, :) = coefficients G_i of system n</span>
<span class="n">Array2DReal</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="s">&quot;H&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span><span class="w"> </span><span class="c1">// H(n, :) = coefficients H_i of system n</span>
<span class="n">Array2DReal</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span><span class="w"> </span><span class="c1">// X(n, :) = rhs of system n</span>

<span class="c1">// fill G, H, X</span>

<span class="n">TriDiagDiffSolver</span><span class="o">::</span><span class="n">solve</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="team-level-method">
<h3>Team-level method<a class="headerlink" href="#team-level-method" title="Permalink to this heading"></a></h3>
<p>Note: since the steps to use the team-level general and specialized solvers are similar,
this subsection first shows how to use the general solver.
At the end, an example of using the specialized solver is presented.</p>
<p>The team-level solvers need to be used inside a parallel loop using Kokkos team
policy. To create a team policy for solving <code class="docutils literal notranslate"><span class="pre">NBatch</span></code> systems of size <code class="docutils literal notranslate"><span class="pre">NRow</span></code>
the static member function <code class="docutils literal notranslate"><span class="pre">makeTeamPolicy</span></code> is used</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TeamPolicy</span><span class="w"> </span><span class="n">Policy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TridDiagSolver</span><span class="o">::</span><span class="n">makeTeamPolicy</span><span class="p">(</span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span>
</pre></div>
</div>
<p>Every team of threads except the last is responsible for solving <code class="docutils literal notranslate"><span class="pre">VecLength</span></code> systems.
Since the total number of systems likely doesn’t evenly divide <code class="docutils literal notranslate"><span class="pre">VecLength</span></code>, the last
team solves fewer than <code class="docutils literal notranslate"><span class="pre">VecLength</span></code> systems. Hence, it is necessary to handle that with
if statements.</p>
<p>Typically, the parallel loop consists of three main parts:</p>
<ul class="simple">
<li><p>defining the system</p></li>
<li><p>solving the system</p></li>
<li><p>using the solution</p></li>
</ul>
<p>At the beginning of the loop, temporary scratch storage for the coefficients of <code class="docutils literal notranslate"><span class="pre">VecLength</span></code> systems
needs to be allocated.
This is done by creating a <code class="docutils literal notranslate"><span class="pre">TriDiagScratch</span></code> struct, which contains
four member arrays <code class="docutils literal notranslate"><span class="pre">DL</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">DU</span></code>, and <code class="docutils literal notranslate"><span class="pre">X</span></code> of size (<code class="docutils literal notranslate"><span class="pre">NRow</span></code>, <code class="docutils literal notranslate"><span class="pre">VecLength</span></code>).
Note that, contrary to the global arrays approach, the system dimension comes first.</p>
<p>These arrays need to be filled with the coefficients of <code class="docutils literal notranslate"><span class="pre">VecLength</span></code> systems solved by the team.
This is done in a parallel loop over system size (using <code class="docutils literal notranslate"><span class="pre">TeamThreadRange</span></code>)
and a serial loop over <code class="docutils literal notranslate"><span class="pre">VecLength</span></code>.
Overall, the code that defines the systems coefficients looks typically like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">parallel_for</span><span class="p">(</span><span class="n">Policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// create scratch data</span>
<span class="w">   </span><span class="n">TriDiagScratch</span><span class="w"> </span><span class="nf">Scratch</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">IStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Member</span><span class="p">.</span><span class="n">league_rank</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// define the systems coefficients</span>
<span class="w">   </span><span class="n">parallel_for</span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IVec</span><span class="p">;</span>
<span class="w">         </span><span class="c1">// handle last team having fewer systems</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NBatch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Scratch</span><span class="p">.</span><span class="n">DL</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">            </span><span class="n">Scratch</span><span class="p">.</span><span class="n">D</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">            </span><span class="n">Scratch</span><span class="p">.</span><span class="n">DU</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">            </span><span class="n">Scratch</span><span class="p">.</span><span class="n">X</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="p">...</span>
<span class="w">   </span><span class="p">});</span>
</pre></div>
</div>
<p>To perform a team-level solve a different overload of the static member function <code class="docutils literal notranslate"><span class="pre">TridDiagSolver::solve</span></code>
needs to be called.
This overload takes the team member <code class="docutils literal notranslate"><span class="pre">Member</span></code> and the filled scratch struct <code class="docutils literal notranslate"><span class="pre">Scratch</span></code>.
This call needs to be surrounded by barriers to ensure that the
parallel loop setting the coefficients has finished and to make the computed solution available to all threads.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">parallel_for</span><span class="p">(</span><span class="n">Policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// previous code</span>

<span class="w">   </span><span class="c1">// solve the system</span>
<span class="w">   </span><span class="n">Member</span><span class="p">.</span><span class="n">team_barrier</span><span class="p">();</span>
<span class="w">   </span><span class="n">TridDiagSolver</span><span class="o">::</span><span class="n">solve</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">Scratch</span><span class="p">);</span>
<span class="w">   </span><span class="n">Member</span><span class="p">.</span><span class="n">team_barrier</span><span class="p">();</span>

<span class="w">   </span><span class="p">...</span>
<span class="p">});</span>
</pre></div>
</div>
<p>After the call to <code class="docutils literal notranslate"><span class="pre">solve</span></code> the solution is available in <code class="docutils literal notranslate"><span class="pre">Scratch.X</span></code>. It can be manipulated further or simply stored.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">parallel_for</span><span class="p">(</span><span class="n">Policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// previous code</span>

<span class="w">   </span><span class="c1">// multiply the solution by 2 (just an example)</span>
<span class="w">   </span><span class="n">parallel_for</span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Scratch</span><span class="p">.</span><span class="n">X</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">});</span>

<span class="w">   </span><span class="n">Member</span><span class="p">.</span><span class="n">team_barrier</span><span class="p">();</span>

<span class="w">   </span><span class="c1">// store the solution</span>
<span class="w">   </span><span class="n">parallel_for</span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IVec</span><span class="p">;</span>
<span class="w">         </span><span class="c1">// handle last team having fewer systems</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NBatch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">X</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Scratch</span><span class="p">.</span><span class="n">X</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">);</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The team-level specialized diffusion solver can be used similarly, the only substantial difference is in the form
of the coefficients. A minimal complete example of using it is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// create team policy</span>
<span class="n">TeamPolicy</span><span class="w"> </span><span class="n">Policy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TridDiagDiffSolver</span><span class="o">::</span><span class="n">makeTeamPolicy</span><span class="p">(</span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span>

<span class="n">parallel_for</span><span class="p">(</span><span class="n">Policy</span><span class="p">,</span><span class="w"> </span><span class="n">KOKKOS_LAMBDA</span><span class="w"> </span><span class="p">(</span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">member</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// create scratch data</span>
<span class="w">   </span><span class="n">TriDiagDiffScratch</span><span class="w"> </span><span class="nf">Scratch</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span>

<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">IStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Member</span><span class="p">.</span><span class="n">league_rank</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// define the systems coefficients</span>
<span class="w">   </span><span class="n">parallel_for</span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IVec</span><span class="p">;</span>
<span class="w">         </span><span class="c1">// handle last team having fewer systems</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NBatch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Scratch</span><span class="p">.</span><span class="n">G</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">            </span><span class="n">Scratch</span><span class="p">.</span><span class="n">H</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">            </span><span class="n">Scratch</span><span class="p">.</span><span class="n">X</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">   </span><span class="c1">// solve the system</span>
<span class="w">   </span><span class="n">Member</span><span class="p">.</span><span class="n">team_barrier</span><span class="p">();</span>
<span class="w">   </span><span class="n">TridDiagDiffSolver</span><span class="o">::</span><span class="n">solve</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">Scratch</span><span class="p">);</span>
<span class="w">   </span><span class="n">Member</span><span class="p">.</span><span class="n">team_barrier</span><span class="p">();</span>

<span class="w">   </span><span class="c1">// store the solution</span>
<span class="w">   </span><span class="n">parallel_for</span><span class="p">(</span><span class="n">TeamThreadRange</span><span class="p">(</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="n">NRow</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">IVec</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VecLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">IVec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IVec</span><span class="p">;</span>
<span class="w">         </span><span class="c1">// handle last team having fewer systems</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NBatch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">X</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Scratch</span><span class="p">.</span><span class="n">X</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">IVec</span><span class="p">);</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Tracers.html" class="btn btn-neutral float-left" title="Tracers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../design/OmegaV0ShallowWater.html" class="btn btn-neutral float-right" title="Omega V0: Shallow Water" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Energy Exascale Earth System Model Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>