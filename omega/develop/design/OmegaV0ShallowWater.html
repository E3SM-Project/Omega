

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Omega V0: Shallow Water</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
      <script src="../_static/jquery.js"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/doctools.js"></script>
      <script src="../_static/sphinx_highlight.js"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Broadcast" href="Broadcast.html" />
    <link rel="prev" title="Tracers" href="../devGuide/Tracers.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Omega
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/QuickStart.html">Quick Start for Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OmegaBuild.html">CMake-based Omega Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Logging.html">Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Dimension.html">Dimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Field.html">Fields and Metadata (Field)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IOStreams.html">IO Streams (IOStream)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/AuxiliaryState.html">Auxiliary State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OceanState.html">Ocean State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TimeStepping.html">Time stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Tracers.html">Tracers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/QuickStart.html">Quick Start for Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/CondaEnv.html">Development Conda Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Linting.html">Linting Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/BuildDocs.html">Building the Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/DataTypes.html#arrays-and-kokkos">Arrays and Kokkos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/CMakeBuild.html">Omega Build with CMake</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Logging.html">Developing Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Dimension.html">Dimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Field.html">Fields and Metadata (Field)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/IOStreams.html">IO Streams (IOStream)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/AuxiliaryState.html">Auxiliary State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/OceanState.html">Ocean State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TimeStepping.html">Time stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Tracers.html">Tracers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design documents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Omega V0: Shallow Water</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">1 Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#requirements">2 Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#omega-0-will-solve-the-nonlinear-shallow-water-equations-plus-inactive-tracers">2.1  Omega-0 will solve the nonlinear shallow water equations, plus inactive tracers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numerical-method-will-be-the-trisk-formulation">2.2  Numerical method will be the TRiSK formulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#omega-0-will-use-mpas-format-unstructured-mesh-domains">2.3  Omega-0 will use MPAS format unstructured-mesh domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#omega-0-will-interface-with-polaris-for-preprocessing-and-postprocessing">2.4  Omega-0 will interface with polaris for preprocessing and postprocessing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#omega-0-will-run-portably-on-various-doe-architectures-cpu-and-gpu-nodes">2.5  Omega-0 will run portably on various DOE architectures (CPU and GPU nodes)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#omega-0-will-run-on-multi-node-with-domain-decomposition">2.6  Omega-0 will run on multi-node with domain decomposition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#correct-convergence-rates-of-operators-and-exact-solutions">2.7  Correct convergence rates of operators and exact solutions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conservation-of-volume-and-tracer">2.8  Conservation of volume and tracer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance-will-be-at-least-as-good-or-better-than-mpas-ocean">2.9  Performance will be at least as good or better than MPAS-Ocean</a></li>
<li class="toctree-l3"><a class="reference internal" href="#full-node-gpu-throughput-will-be-comparable-or-better-than-full-node-cpu-throughput">2.10  Full-node GPU throughput will be comparable or better than full-node CPU throughput</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algorithmic-formulation">3 Algorithmic Formulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#governing-equations">3.1 Governing Equations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#continuous-equations">3.1.1 Continuous Equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#discrete-equations">3.1.2 Discrete Equations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#variable-definitions">3.2 Variable Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operator-formulation">3.2 Operator Formulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#divergence">3.2.1. Divergence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gradient">3.2.2. Gradient</a></li>
<li class="toctree-l4"><a class="reference internal" href="#curl">3.2.3. Curl</a></li>
<li class="toctree-l4"><a class="reference internal" href="#perpendicular-vector-component">3.2.4. Perpendicular vector component</a></li>
<li class="toctree-l4"><a class="reference internal" href="#perpendicular-gradient">3.2.5. Perpendicular Gradient</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cell-to-edge-interpolation">3.2.6. Cell to Edge Interpolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vertex-to-edge-interpolation">3.2.7. Vertex to Edge Interpolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cell-to-vertex-interpolation">3.2.8. Cell to Vertex Interpolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vertex-to-cell-interpolation">3.2.9. Vertex to Cell Interpolation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vector-from-edge-to-cell">3.2.10. Vector from Edge to Cell</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#momentum-terms">3.3 Momentum Terms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kinetic-energy-gradient">3.3.1. Kinetic energy gradient</a></li>
<li class="toctree-l4"><a class="reference internal" href="#potential-vorticity-term">3.3.2. Potential vorticity term</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sea-surface-height-gradient">3.3.3. Sea surface height gradient</a></li>
<li class="toctree-l4"><a class="reference internal" href="#del2-momentum-dissipation">3.3.4. Del2 momentum dissipation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#del4-momentum-dissipation">3.3.5. Del4 momentum dissipation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rayleigh-drag">3.3.6. Rayleigh Drag</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bottom-drag">3.3.7. Bottom drag</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wind-forcing">3.3.8. Wind forcing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thickness-and-tracer-terms">3.4 Thickness and Tracer Terms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tracer-advection">3.4.1. Tracer advection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#del2-tracer-diffusion">3.4.2. Del2 tracer diffusion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#del4-tracer-diffusion">3.4.3. Del4 tracer diffusion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#design">4 Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="#verification-and-testing">5 Verification and Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#convergence-of-individual-terms">5.1 Convergence of individual terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inertia-gravity-wave-linearized-shallow-water-no-tracers">5.2 Inertia Gravity Wave: linearized shallow water, no tracers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#manufactured-solution-full-nonlinear-shallow-water-no-tracers">5.3 Manufactured Solution: full nonlinear shallow water, no tracers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tracer-transport-on-a-sphere">5.4 Tracer transport on a sphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance-testing">5.5 Performance testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shallow-water-tests-on-spherical-domains-and-with-realistic-coastlines">5.6 Shallow water tests on spherical domains and with realistic coastlines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#further-tests-for-omega-0">5.7 Further tests for Omega-0</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Broadcast.html">Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="Config.html">Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html">DataTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decomp.html">Decomp</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver and Component Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Error.html">ErrorHandler (Error)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Halo.html">Halo</a></li>
<li class="toctree-l1"><a class="reference internal" href="HorzMeshClass.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="MachEnv.html">MachineEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="Metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO.html">Input/Output (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="IOStreams.html">IOStreams</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="State.html">State</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tendency.html">Tendency</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="AuxiliaryVariables.html">Auxiliary variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="AuxiliaryState.html">AuxiliaryState</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeMgr.html">TimeManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timers.html">Timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepping.html">Time Stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tracers.html">Tracer Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="TridiagonalSolver.html">Tridiagonal Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="VerticalMixingCoeff.html">Vertical Mixing Coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="Template.html">Template</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Omega</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Omega V0: Shallow Water</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/design/OmegaV0ShallowWater.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="omega-v0-shallow-water">
<span id="omega-design-shallow-water-omega0"></span><h1>Omega V0: Shallow Water<a class="headerlink" href="#omega-v0-shallow-water" title="Permalink to this heading"></a></h1>
<p><strong>Table of Contents</strong></p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#overview">Overview</a></p></li>
<li><p><a class="reference internal" href="#requirements">Requirements</a></p></li>
<li><p><a class="reference internal" href="#algorithmic-formulation">Algorithmic Formulation</a></p></li>
<li><p><a class="reference internal" href="#design">Design</a></p></li>
<li><p><a class="reference internal" href="#verification-and-testing">Verification and Testing</a></p></li>
</ol>
<section id="overview">
<h2>1 Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>This design document describes the first version of the Omega ocean model, Omega-0. Overall, Omega is an unstructured-mesh ocean model based on TRiSK numerical methods (<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109004434">Thuburn et al. 2009</a>) that is specifically designed for modern exascale computing architectures. The algorithms in Omega will be nearly identical to those in MPAS-Ocean, but it will be written in c++ rather than Fortran in order to take advantage of libraries to run on GPUs, such as Kokkos (<a class="reference external" href="https://ieeexplore.ieee.org/document/9485033">Trott et al. 2022</a>).</p>
<p>The planned versions of Omega are:</p>
<ol class="arabic simple">
<li><p><strong>Omega-0: Shallow water equations with identical vertical layers and inactive tracers.</strong> There is no vertical transport or advection. The tracer equation is horizontal advection-diffusion, but tracers do not feed back to dynamics. Pressure gradient is simply gradient of sea surface height. Capability is similar to <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a></p></li>
<li><p><strong>Omega-1: Minimal stand-alone primitive equation eddy-permitting model.</strong> This adds active temperature, salinity, density, and pressure as a function of depth. There is a true pressure gradient. Vertical velocity is from the continuity equation. An equation of state and simple vertical mixing scheme are needed. Capability is same as <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1463500313000760">Ringler et al. 2013</a></p></li>
<li><p><strong>Omega-2: Eddying ocean with advanced parameterizations.</strong> This model will have sufficient capability to run realistic global simulations, similar to E3SM V1 <a class="reference external" href="https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2018MS001373">Petersen et al. 2019</a>.</p></li>
</ol>
<p>We will produce separate design documents for the time-stepping scheme and the tracer equations in Omega-0. Some of the requirements stated here are repeated or implied by the Omega framework design documents, but are included for clarity.</p>
</section>
<section id="requirements">
<h2>2 Requirements<a class="headerlink" href="#requirements" title="Permalink to this heading"></a></h2>
<section id="omega-0-will-solve-the-nonlinear-shallow-water-equations-plus-inactive-tracers">
<h3>2.1  Omega-0 will solve the nonlinear shallow water equations, plus inactive tracers<a class="headerlink" href="#omega-0-will-solve-the-nonlinear-shallow-water-equations-plus-inactive-tracers" title="Permalink to this heading"></a></h3>
<p>The governing equations for Omega-0 are the shallow water equations, as described in <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> eqns 2-7, plus the tracer advection-diffusion equation. These equations are derived from conservation of momentum, volume, and tracers in a single layer. The code will solve a multi-layer formulation with independent, redundant layers in order to test performance with a vertical array dimension. The exact formulation is specified section 3.1 below, with variable definitions in section 3.2.</p>
<p>Boundary conditions will include both no-slip and free-slip. The original MPAS-Ocean implementation had no-slip boundaries, implemented by setting vorticity to zero at the boundaries. The free-slip implementation is described by Darren Engwirda in a <a class="reference external" href="https://github.com/E3SM-Ocean-Discussion/E3SM/pull/49">github discussion</a>.</p>
</section>
<section id="numerical-method-will-be-the-trisk-formulation">
<h3>2.2  Numerical method will be the TRiSK formulation<a class="headerlink" href="#numerical-method-will-be-the-trisk-formulation" title="Permalink to this heading"></a></h3>
<p>The horizontal discretization will be taken from
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109004434">Thuburn et al. 2009</a> and <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a>, as described in the algorithmic formulation in Section 3 below. This is the same base formulation as in MPAS-Ocean. In addition, we will consider small alterations from the original MPAS-Ocean horizontal discretization and include them as options if they are of minimal additional effort and improve the simulated climate. This includes the recent AUST formulation in <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S146350032100161X">Calandrini et al. 2021</a> and simple vorticity averaging considered by the Omega team this past year.</p>
</section>
<section id="omega-0-will-use-mpas-format-unstructured-mesh-domains">
<h3>2.3  Omega-0 will use MPAS format unstructured-mesh domains<a class="headerlink" href="#omega-0-will-use-mpas-format-unstructured-mesh-domains" title="Permalink to this heading"></a></h3>
<p>We will continue to use the MPAS-format netcdf files for input and output, with the same mesh variable names and dimensions. This will facilitate ease of use and interoperability between MPAS-Ocean and Omega.</p>
<p>Omega mesh information will be stored in a separate mesh file, and not be included with initial condition, restart, or output files. This way there is never redundant mesh data stored in these files.</p>
</section>
<section id="omega-0-will-interface-with-polaris-for-preprocessing-and-postprocessing">
<h3>2.4  Omega-0 will interface with polaris for preprocessing and postprocessing<a class="headerlink" href="#omega-0-will-interface-with-polaris-for-preprocessing-and-postprocessing" title="Permalink to this heading"></a></h3>
<p>A substantial investment has already been made in the polaris tools. Continuing the use of polaris for Omega will speed development and encourage the documentation and long-term reproducibility of test cases.</p>
<p>The test cases relevant to this design document are in Section 5 below.</p>
</section>
<section id="omega-0-will-run-portably-on-various-doe-architectures-cpu-and-gpu-nodes">
<h3>2.5  Omega-0 will run portably on various DOE architectures (CPU and GPU nodes)<a class="headerlink" href="#omega-0-will-run-portably-on-various-doe-architectures-cpu-and-gpu-nodes" title="Permalink to this heading"></a></h3>
<p>Omega will be able to run on all the upcoming DOE architectures and make good use of GPU hardware. This should occur with minimal alterations in the high-level PDE solver code for different platforms.</p>
<p>Options include: writing kernels directly for GPUs in CUDA; adding OpenACC pragmas for the GPUs; or calling libraries such as Kokkos (<a class="reference external" href="https://ieeexplore.ieee.org/document/9485033">Trott et al. 2022</a>), YAKL (<a class="reference external" href="https://link.springer.com/10.1007/s10766-022-00739-0">Norman et al. 2023</a>) or <a class="reference external" href="https://github.com/ROCm-Developer-Tools/HIP">HIP</a> that execute code optimized for specialized architectures on the back-end, while providing a simpler front-end interface for the domain scientist.</p>
</section>
<section id="omega-0-will-run-on-multi-node-with-domain-decomposition">
<h3>2.6  Omega-0 will run on multi-node with domain decomposition<a class="headerlink" href="#omega-0-will-run-on-multi-node-with-domain-decomposition" title="Permalink to this heading"></a></h3>
<p>This is with MPI and halo communication, as described in framework design documents. Results must be bit-for-bit identical across different number of partitions. This may be demonstrated with the ‘’QU240 partition test’’ in Polaris.</p>
</section>
<section id="correct-convergence-rates-of-operators-and-exact-solutions">
<h3>2.7  Correct convergence rates of operators and exact solutions<a class="headerlink" href="#correct-convergence-rates-of-operators-and-exact-solutions" title="Permalink to this heading"></a></h3>
<p>Each operator will be tested individually for the proper convergence rate: divergence, gradient, curl interpolated to cell centers, and tangential velocity are all second order; curl at vertices is first order. The details of the convergence tests are explained in section 5.1 below.</p>
</section>
<section id="conservation-of-volume-and-tracer">
<h3>2.8  Conservation of volume and tracer<a class="headerlink" href="#conservation-of-volume-and-tracer" title="Permalink to this heading"></a></h3>
<p>The total volume of the domain should be conserved to machine precision in the absence of surface volume fluxes. Likewise, the total tracer amount should be conserved to machine precision without surface fluxes. A simple test is to initialize an inactive test tracer with a uniform value of 1.0, and it should remain 1.0 throughout the domain.</p>
</section>
<section id="performance-will-be-at-least-as-good-or-better-than-mpas-ocean">
<h3>2.9  Performance will be at least as good or better than MPAS-Ocean<a class="headerlink" href="#performance-will-be-at-least-as-good-or-better-than-mpas-ocean" title="Permalink to this heading"></a></h3>
<p>Performance will be assessed with the following metrics:</p>
<ol class="arabic simple">
<li><p>Single CPU throughput</p></li>
<li><p>Parallel CPU scalability to high node counts</p></li>
<li><p>Single GPU throughput</p></li>
</ol>
<p>The first two items will be compared to MPAS-Ocean with the same test configuration. For Omega-0, these may be tested first with the layered shallow water equations (momentum and thickness only) and be compared directly to the results in <a class="reference external" href="https://gmd.copernicus.org/articles/16/5539/2023">Bishnu et al. 2023</a>, using the inertia-gravity wave test case described in Section 6.2 below. After tracer transport capabilities are added, performance may be compared against MPAS-Ocean with test cases using active tracers in addition to momentum and thickness.</p>
<p>For these comparisons, MPAS-Ocean will be set up with the identical terms and functionality as Omega-0. This means that vertical advection, vertical mixing, and all parameterizations will be disabled. Comparisons with these terms will be made with Omega-1 and higher and will be described in future design documents.</p>
</section>
<section id="full-node-gpu-throughput-will-be-comparable-or-better-than-full-node-cpu-throughput">
<h3>2.10  Full-node GPU throughput will be comparable or better than full-node CPU throughput<a class="headerlink" href="#full-node-gpu-throughput-will-be-comparable-or-better-than-full-node-cpu-throughput" title="Permalink to this heading"></a></h3>
<p>For GPU throughput, comparisons should be made between full-node CPU throughput and full-node GPU throughput. For example, <a class="reference external" href="https://docs.nersc.gov/systems/perlmutter/architecture/">Perlmutter at NERSC</a> has nodes with 64 and 128 CPU cores (AMD EPYC 7763) and 4 GPUs (NVIDIA A100). We expect the full-node GPU throughput to be at least as good as the full-node CPU throughput, and potentially a factor of four higher. These numbers depend on the performance specifications of the particular hardware.</p>
<p>Like the previous requirement, tests will first be conducted with layered shallow water equations and later with additional tracer advection. For reference, <a class="reference external" href="https://gmd.copernicus.org/articles/16/5539/2023">Bishnu et al. 2023</a> was able to obtain nearly identical throughput between 64 CPU cores and a single GPU on Perlmutter using a Julia code and a layered shallow water test case.</p>
</section>
</section>
<section id="algorithmic-formulation">
<h2>3 Algorithmic Formulation<a class="headerlink" href="#algorithmic-formulation" title="Permalink to this heading"></a></h2>
<section id="governing-equations">
<h3>3.1 Governing Equations<a class="headerlink" href="#governing-equations" title="Permalink to this heading"></a></h3>
<section id="continuous-equations">
<h4>3.1.1 Continuous Equations<a class="headerlink" href="#continuous-equations" title="Permalink to this heading"></a></h4>
<p>The algorithms for Omega-0 are given here in full detail, with all variables defined in section 3.2 below.
We begin with the standard shallow water equations, which are derived from conservation of momentum and mass in a single layer with uniform density in a rotating frame. The standard presentation may be found in standard textbooks on Geophysical Fluid Dynamics, such as those by Vallis (2017), Cushman‐Roisin and Beckers (2011), Pedlosky (1987), and Gill (2016). See references at bottom. In continuous form, these are</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \boldsymbol{u}}{\partial t} + \left(\boldsymbol{u}\cdot\nabla\right)\boldsymbol{u}  + f \boldsymbol{k}\times\boldsymbol{u}
= -g\nabla(h-b)
\hspace{1cm}
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{\partial h}{\partial t} + \nabla \cdot \left(h \boldsymbol{u}\right) = 0,
\hspace{1cm}
\]</div>
<p>Next we replace the non-linear advection term with the right-hand side of the vector identity
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{u} \cdot \nabla \boldsymbol{u} &amp;= (\nabla \times \boldsymbol{u}) \times \boldsymbol{u} + \nabla \frac{|\boldsymbol{u}|^2}{2} \\
&amp;= \{\boldsymbol{k} \cdot (\nabla \times \boldsymbol{u})\} \boldsymbol{k} \times \boldsymbol{u} + \nabla \frac{|\boldsymbol{u}|^2}{2} \\
&amp;= \omega \boldsymbol{u}^{\perp} + \nabla K.
\end{split}\]</div>
</p>
<p>The governing equations for Omega-0 in continuous form are then
<div class="math notranslate nohighlight">
\[
\frac{\partial \boldsymbol{u}}{\partial t} + q\left(h\boldsymbol{u}^{\perp}\right) = -g\nabla(h-b) - \nabla K + \nu_2 \nabla^2 \boldsymbol{u} - \nu_4 \nabla^4 \boldsymbol{u} + \mathcal{D} + \mathcal{F}
\hspace{1cm}   (1)
\]</div>
</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial h}{\partial t} + \nabla \cdot \left(h \boldsymbol{u}\right) = 0,
\hspace{1cm}   (2)
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{\partial h \phi}{\partial t} + \nabla \cdot \left(h \boldsymbol{u} \phi\right) = \kappa_2 h \nabla^2 \phi - \kappa_4 h \nabla^4 \phi.
\hspace{1cm}   (3)
\]</div>
<p>These are typically referred to as the momentum equation (or velocity equation), the thickness equation, and the tracer equation.</p>
<p>The additional momentum terms in (1) are viscous dissipation (del2 and del4), and drag and forcing are as follows:
<div class="math notranslate nohighlight">
\[
\mathcal{D} = -Ra \, \boldsymbol{u}-C_D \frac{\boldsymbol{u}\left|\boldsymbol{u}\right|}{h}
\]</div>
</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F} = - C_W \frac{(\boldsymbol{u}_W - \boldsymbol{u})\left|\boldsymbol{u}_W - \boldsymbol{u}\right|}{h}
\]</div>
<p>The drag consists of simple Rayleigh drag for spin-up as well as quadratic bottom drag. The forcing is a quadratic wind forcing (see equation 1 in <a class="reference external" href="https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2022MS003327">Lilly et al. 2023</a>).</p>
<p>Here <span class="math notranslate nohighlight">\(q\)</span> is the potential vorticity, so that the term
<div class="math notranslate nohighlight">
\[
q\left(h\boldsymbol{u}^{\perp}\right) = \frac{\omega + f}{h}\left(h\boldsymbol{u}^{\perp}\right)
 = \omega \boldsymbol{u}^{\perp} + f \boldsymbol{u}^{\perp}
\]</div>

is composed of the rotational part of the advection <span class="math notranslate nohighlight">\(\omega \boldsymbol{u}^{\perp}\)</span> and the Coriolis term <span class="math notranslate nohighlight">\(f \boldsymbol{u}^{\perp}\)</span>. This term is discussed in <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> sections 2.1 and 2.2.</p>
<p>The thickness equation (2) is derived from conservation of mass for a fluid with constant density, which reduces to conservation of volume. The model domain uses fixed horizontal cells with horizontal areas that are constant in time, so the area drops out and only the layer thickness <span class="math notranslate nohighlight">\(h\)</span> remains as the prognostic variable.</p>
<p>The Tracer Equation (3) is the conservation equation for a passive tracer (scalar), with only advective and diffusive terms. It is not included in the textbook Shallow Water equations, but is useful for us to test tracer advection in preparation for a primitive equation model in Omega-1. For a tracer which is uniformly one (<span class="math notranslate nohighlight">\(\phi=1\)</span>), with no viscous terms, the tracer equation reduces to the thickness equation.
The tracer equation is thickness weighted, because the conserved quantity is the tracer mass. Here <span class="math notranslate nohighlight">\((h\phi A)\)</span> typically has units of mass of the tracer in [kg] while <span class="math notranslate nohighlight">\(\phi\)</span> has units of concentration [kg m<span class="math notranslate nohighlight">\(^{-3}\)</span>]. Because the horizontal area is fixed, <span class="math notranslate nohighlight">\(A\)</span> has been divided out making (3) thickness weighted, rather than volume weighted. For chemical tracers <span class="math notranslate nohighlight">\(\phi\)</span> has units of [mmol m<span class="math notranslate nohighlight">\(^{-3}\)</span>]; salinity has units of Practical Salinity Units (PSU) and potential temperature has units of [C]. A derivation of the thickness-weighted tracer equation appears in Appendix A-2 of <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1463500313000760">Ringler et al. 2013</a>.</p>
<p>The Omega-0 governing equations (1-3) do not include any vertical advection or diffusion. Omega-0 will have a vertical index for performance testing and future expansion, but vertical layers will simply be redundant.</p>
<p>Further details of these derivations are given in <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109004434">Thuburn et al. 2009</a> and <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> eqns. (2) and (7), and <a class="reference external" href="https://doi.org/10.1029/2022MS003545">Bishnu et al. 2024</a>, Section 2.1.
Additional information on governing equations may be found in chapter 8 of the MPAS User’s Guide (<a class="reference external" href="https://zenodo.org/records/11098080">Petersen et al. 2024</a>).
Publications that evaluate TRiSK against alternative formulations include <a class="reference external" href="http://journals.ametsoc.org/doi/10.1175/MWR-D-11-00193.1">Weller et al. 2012</a>,
<a class="reference external" href="https://epubs.siam.org/doi/10.1137/110850293">Thuburn and Cotter 2012</a>,
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S146350032100161X">Calandrini et al. 2021</a> and
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1463500324000222">Lapolli et al. 2024</a>.</p>
</section>
<section id="discrete-equations">
<h4>3.1.2 Discrete Equations<a class="headerlink" href="#discrete-equations" title="Permalink to this heading"></a></h4>
<p>The discretized versions of the governing equations are</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial u_e}{\partial t} + \left[ \frac{{\boldsymbol k} \cdot \nabla \times u_e +f_v}{[h_i]_v}\right]_e\left([h_i]_e u_e^{\perp}\right)
= -g\nabla(h_i-b_i) - \nabla K_i + \nu_2 \nabla^2 u_e - \nu_4 \nabla^4 u_e + \mathcal{D}_e + \mathcal{F}_e
\hspace{1cm}   (4)
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{\partial h_i}{\partial t} + \nabla \cdot \left([h_i]_e u_e\right) = 0,
\hspace{1cm}   (5)
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{\partial h_i \phi_i}{\partial t} + \nabla \cdot \left(u_e [h_i \phi_i]_e \right) = \kappa_2 h_i \nabla^2 \phi_i - \kappa_4 h_i \nabla^4 \phi_i,
\hspace{1cm}   (6)
\]</div>
<p>where subscripts <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(e\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> indicate cell, edge, and vertex locations (<span class="math notranslate nohighlight">\(i\)</span> was chosen for cell because <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(e\)</span> look similar).  Here square brackets <span class="math notranslate nohighlight">\([\cdot]_e\)</span> and <span class="math notranslate nohighlight">\([\cdot]_v\)</span> are quantities that are interpolated to edge and vertex locations. The interpolation is typically centered, but may vary by method, particularly for advection schemes. For vector quantities, <span class="math notranslate nohighlight">\(u_e\)</span> denotes the normal component at the center of the edge, while <span class="math notranslate nohighlight">\(u_e^\perp\)</span> denotes the tangential component. In the discrete system, the normal component <span class="math notranslate nohighlight">\(u_e\)</span> points positively from the lower cell index to the higher cell index, while the tangential component <span class="math notranslate nohighlight">\(u_e^\perp\)</span> points positively <span class="math notranslate nohighlight">\(90^o\)</span> to the left of <span class="math notranslate nohighlight">\(u_e\)</span> (for unit vectors, <span class="math notranslate nohighlight">\({\bf n}_e^\perp = {\bf k}\times {\bf n}_e\)</span>).</p>
<p>The discretized momentum drag and forcing terms are
<div class="math notranslate nohighlight">
\[
\mathcal{D}_e = - Ra \, u_e - C_D \frac{u_e\left|u_e\right|}{[h_i]_e}
\]</div>
</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F}_e =  C_W \frac{(u_W - u_e)\left|u_W - u_e\right|}{[h_i]_e}
\]</div>
</section>
</section>
<section id="variable-definitions">
<h3>3.2 Variable Definitions<a class="headerlink" href="#variable-definitions" title="Permalink to this heading"></a></h3>
<p>Table 1. Definition of variables</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>symbol</p></th>
<th class="head"><p>name</p></th>
<th class="head"><p>units</p></th>
<th class="head"><p>location</p></th>
<th class="head"><p>name in code</p></th>
<th class="head"><p>notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(A_i \)</span></p></td>
<td><p>cell area</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>cell</p></td>
<td><p>AreaCell</p></td>
<td><p>area of polygon <span class="math notranslate nohighlight">\(P_i\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\({\bar A}_{e}\)</span></p></td>
<td><p>edge area</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>edge</p></td>
<td><p>none</p></td>
<td><p>rectangle area about edge <span class="math notranslate nohighlight">\(e\)</span>: <span class="math notranslate nohighlight">\({\bar A}_{e} = l_e d_e\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\({\hat A}_{v}\)</span></p></td>
<td><p>vertex area</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>vertex</p></td>
<td><p>none</p></td>
<td><p>triangle area (dual cell <span class="math notranslate nohighlight">\(D_v\)</span>) about vertex <span class="math notranslate nohighlight">\(v\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\({\tilde A}_{v,i}\)</span></p></td>
<td><p>kite area</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>vertex</p></td>
<td><p>none</p></td>
<td><p>kite area between <span class="math notranslate nohighlight">\(x_v\)</span> and <span class="math notranslate nohighlight">\(x_c\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(b\)</span></p></td>
<td><p>bottom depth (pos. down)</p></td>
<td><p>m</p></td>
<td><p>cell</p></td>
<td><p>BottomDepth</p></td>
<td><p>bathymetry; always positive.</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(C_D\)</span></p></td>
<td><p>bottom drag</p></td>
<td><p>1/m</p></td>
<td><p>constant</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(C_W\)</span></p></td>
<td><p>wind stress coefficient</p></td>
<td><p>1/m</p></td>
<td><p>constant</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(d_e \)</span></p></td>
<td><p>cell separation distance across edge</p></td>
<td><p>m</p></td>
<td><p>edge</p></td>
<td><p>DcEdge</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(D\)</span></p></td>
<td><p>divergence</p></td>
<td><p>1/s</p></td>
<td><p>cell</p></td>
<td><p>Divergence</p></td>
<td><p><span class="math notranslate nohighlight">\(D=\nabla\cdot\boldsymbol u\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\mathcal{D} \)</span></p></td>
<td><p>drag</p></td>
<td><p>m/s<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>edge</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(f\)</span></p></td>
<td><p>Coriolis parameter</p></td>
<td><p>1/s</p></td>
<td><p>vertex</p></td>
<td><p>FVertex</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\mathcal{F} \)</span></p></td>
<td><p>forcing</p></td>
<td><p>m/s<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>edge</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(g\)</span></p></td>
<td><p>gravitational acceleration</p></td>
<td><p>m/s<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>constant</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(h\)</span></p></td>
<td><p>thickness of layer</p></td>
<td><p>m</p></td>
<td><p>cell</p></td>
<td><p>LayerThickness</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\({\boldsymbol k}\)</span></p></td>
<td><p>vertical unit vector</p></td>
<td><p>unitless</p></td>
<td><p>none</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(K\)</span></p></td>
<td><p>kinetic energy</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^2\)</span>/s<span class="math notranslate nohighlight">\(^2\)</span></p></td>
<td><p>cell</p></td>
<td><p>KineticEnergyCell</p></td>
<td><p><span class="math notranslate nohighlight">\(K = \left| {\boldsymbol u} \right|^2 / 2\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(l_e \)</span></p></td>
<td><p>edge length (vertex span)</p></td>
<td><p>m</p></td>
<td><p>edge</p></td>
<td><p>DvEdge</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(n_{e,i}\)</span></p></td>
<td><p>edge normal sign</p></td>
<td><p>unitless</p></td>
<td><p>edge</p></td>
<td><p>EdgeSignOnCell</p></td>
<td><p>also by index ordering of CellsOnEdge</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(q\)</span></p></td>
<td><p>potential vorticity</p></td>
<td><p>1/m/s</p></td>
<td><p>vertex</p></td>
<td><p></p></td>
<td><p><span class="math notranslate nohighlight">\(q = \eta/h = \left(\omega+f\right)/h\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(Ra\)</span></p></td>
<td><p>Rayleigh drag coefficient</p></td>
<td><p>1/s</p></td>
<td><p>constant</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(t\)</span></p></td>
<td><p>time</p></td>
<td><p>s</p></td>
<td><p>none</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(t_{e,v}\)</span></p></td>
<td><p>edge tangential sign</p></td>
<td><p>unitless</p></td>
<td><p>edge</p></td>
<td><p>EdgeSignOnVertex</p></td>
<td><p>also by index ordering of VerticesOnEdge</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\({\boldsymbol u}\)</span></p></td>
<td><p>velocity, vector form</p></td>
<td><p>m/s</p></td>
<td><p>edge</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(u_e\)</span></p></td>
<td><p>velocity, normal to edge</p></td>
<td><p>m/s</p></td>
<td><p>edge</p></td>
<td><p>NormalVelocity</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(u^\perp_e\)</span></p></td>
<td><p>velocity, tangential to edge</p></td>
<td><p>m/s</p></td>
<td><p>edge</p></td>
<td><p>TangentialVelocity</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\({\boldsymbol u}_W\)</span></p></td>
<td><p>wind velocity</p></td>
<td><p>m/s</p></td>
<td><p>edge</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(w_{e,e'}\)</span></p></td>
<td><p>tangential edge weights</p></td>
<td><p>unitless</p></td>
<td><p>edge</p></td>
<td><p></p></td>
<td><p>weights defined in <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> eqn 24</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\({\tilde w}_{e,e'}\)</span></p></td>
<td><p>normalized tangential edge weights</p></td>
<td><p>unitless</p></td>
<td><p>edge</p></td>
<td><p>WeightsOnEdge</p></td>
<td><p>normalized weights, <span class="math notranslate nohighlight">\({\tilde w}_{e,e'} = \tfrac{l_{e'}}{d_e} w_{e,e'}\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\eta\)</span></p></td>
<td><p>absolute vorticity</p></td>
<td><p>1/s</p></td>
<td><p>vertex</p></td>
<td><p></p></td>
<td><p><span class="math notranslate nohighlight">\(\eta=\omega + f\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\kappa_2\)</span></p></td>
<td><p>tracer diffusion</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^2\)</span>/s</p></td>
<td><p>cell</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\kappa_4\)</span></p></td>
<td><p>biharmonic tracer diffusion</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^4\)</span>/s</p></td>
<td><p>cell</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\nu_2\)</span></p></td>
<td><p>viscosity</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^2\)</span>/s</p></td>
<td><p>edge</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\nu_4\)</span></p></td>
<td><p>biharmonic viscosity</p></td>
<td><p>m<span class="math notranslate nohighlight">\(^4\)</span>/s</p></td>
<td><p>edge</p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\phi\)</span></p></td>
<td><p>tracer</p></td>
<td><p>varies</p></td>
<td><p>cell</p></td>
<td><p></p></td>
<td><p>units may be kg/m<span class="math notranslate nohighlight">\(^3\)</span> or similar</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\omega\)</span></p></td>
<td><p>relative vorticity</p></td>
<td><p>1/s</p></td>
<td><p>vertex</p></td>
<td><p>RelativeVorticity</p></td>
<td><p><span class="math notranslate nohighlight">\(\omega={\boldsymbol k} \cdot \left( \nabla \times {\boldsymbol u}\right)\)</span></p></td>
</tr>
</tbody>
</table>
<!--- Note: Table created with [markdown table generator](https://www.tablesgenerator.com/markdown_tables) and original [google sheet](https://docs.google.com/spreadsheets/d/1rz-QXDiwfemq5NpSR1XsvomI7aSKQ1myTNweCY4afcE/edit#gid=0). --->
<p>Table 2. Definition of geometric elements used to build the discrete system.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Element</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Definition</p></th>
<th class="head"><p>MPAS mesh name</p></th>
<th class="head"><p>spherical</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(x_i\)</span></p></td>
<td><p>point</p></td>
<td><p>Location of center of primal mesh cells (cell center)</p></td>
<td><p>(XCell, YCell, ZCell)</p></td>
<td><p>(LonCell, LatCell)</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(x_e\)</span></p></td>
<td><p>point</p></td>
<td><p>Location of edge points where velocity is defined</p></td>
<td><p>(XEdge, YEdge, ZEdge)</p></td>
<td><p>(LonEdge, LatEdge)</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(x_v\)</span></p></td>
<td><p>point</p></td>
<td><p>Location of center of dual-mesh cells (Vertex)</p></td>
<td><p>(XVertex, YVertex, ZVertex)</p></td>
<td><p>(LonVertex, LatVertex)</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(d_e\)</span></p></td>
<td><p>line</p></td>
<td><p>segment distance between neighboring <span class="math notranslate nohighlight">\(x_i\)</span> locations</p></td>
<td><p>DcEdge</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(l_e\)</span></p></td>
<td><p>line</p></td>
<td><p>segment distance between neighboring <span class="math notranslate nohighlight">\(x_v\)</span> locations</p></td>
<td><p>DvEdge</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(P_i\)</span></p></td>
<td><p>cell</p></td>
<td><p>A cell on the primal mesh</p></td>
<td><p>AreaCell</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(D_v\)</span></p></td>
<td><p>cell</p></td>
<td><p>A cell on the dual-mesh</p></td>
<td><p>AreaTriangle</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><img alt="Variable positions for MPAS mesh specification." src="../_images/variablePosition.png" /></p>
<p>Figure 1. Variable positions for MPAS mesh specification.</p>
<p><img alt="Areas for MPAS mesh specification." src="../_images/areaPositionsMPAS.png" /></p>
<p>Figure 2. Areas for MPAS mesh specification.</p>
<p>Table 3. Definition of element groups used to build the discrete system.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Syntax</p></th>
<th class="head"><p>Definition</p></th>
<th class="head"><p>MPAS mesh name</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(e\in EC(i)\)</span></p></td>
<td><p>Set of edges that define the boundary of <span class="math notranslate nohighlight">\(P_i\)</span></p></td>
<td><p>EdgesOnCell</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(e\in EV(v)\)</span></p></td>
<td><p>Set of edges that define the boundary of <span class="math notranslate nohighlight">\(D_v\)</span></p></td>
<td><p>EdgesOnVertex</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(i\in CE(e)\)</span></p></td>
<td><p>Two primal mesh cells that share edge <span class="math notranslate nohighlight">\(e\)</span></p></td>
<td><p>CellsOnEdge</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(i\in CV(v)\)</span></p></td>
<td><p>Set of primal mesh cells that form the vertices of dual mesh cell <span class="math notranslate nohighlight">\(D_v\)</span></p></td>
<td><p>CellsOnVertex</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(v\in VE(e)\)</span></p></td>
<td><p>The two dual-mesh cells that share edge <span class="math notranslate nohighlight">\(e\)</span></p></td>
<td><p>VerticesOnEdge</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(v\in VC(i)\)</span></p></td>
<td><p>The set of dual-mesh cells that form the vertices of primal mesh cell <span class="math notranslate nohighlight">\(P_i\)</span></p></td>
<td><p>VerticesOnCell</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(e\in ECP(e)\)</span></p></td>
<td><p>Edges of cell pair meeting at edge <span class="math notranslate nohighlight">\(e\)</span></p></td>
<td><p>EdgesOnEdge</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(e\in EVC(v,i)\)</span></p></td>
<td><p>Edge pair associated with vertex v and mesh cell <span class="math notranslate nohighlight">\(i\)</span></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p>The definitions of geometric variables may be found in
<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0021999109004434">Thuburn et al. 2009</a>,
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a>, and
<a class="reference external" href="https://epubs.siam.org/doi/10.1137/110850293">Thuburn and Cotter 2012</a>.</p>
</section>
<section id="operator-formulation">
<h3>3.2 Operator Formulation<a class="headerlink" href="#operator-formulation" title="Permalink to this heading"></a></h3>
<p>The TRiSK formulation of the discrete operators are as follows. See <a class="reference external" href="https://gmd.copernicus.org/articles/16/5539/2023">Bishnu et al. 2023</a> section 4.1 and Figure 1 for a description and documentation of convergence rates, as well as <a class="reference external" href="https://doi.org/10.5281/zenodo.7439539">Bishnu et al. 2021</a>. All TRiSK spatial operators show second-order convergence on a uniform hexagon grid, except for the curl on vertices, which is first order. The curl interpolated from vertices to cell centers regains second order convergence. The rates of convergence are typically less than second order on nonuniform meshes, including spherical meshes.</p>
<section id="divergence">
<h4>3.2.1. Divergence<a class="headerlink" href="#divergence" title="Permalink to this heading"></a></h4>
<p>The divergence operator maps a vector field’s edge normal component <span class="math notranslate nohighlight">\(F_e\)</span> to a cell center (<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> eqn 21),</p>
<div class="math notranslate nohighlight">
\[
\left( \nabla \cdot {\bf F}\right)_i
\equiv \nabla \cdot F_e
=  \frac{1}{A_i} \sum_{e\in EC(i)} n_{e,i} \, F_e \, l_e,
\]</div>
<p>where <span class="math notranslate nohighlight">\(A_i\)</span> is the area of cell <span class="math notranslate nohighlight">\(i\)</span>. The indicator function <span class="math notranslate nohighlight">\(n_{e,i}=1\)</span> when the normal vector <span class="math notranslate nohighlight">\({\bf n}_e\)</span> is an <em>outward</em> normal of cell <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(n_{e,i}=-1\)</span> when <span class="math notranslate nohighlight">\({\bf n}_e\)</span> is an <em>inward</em> normal of cell <span class="math notranslate nohighlight">\(i\)</span>.
The notation <span class="math notranslate nohighlight">\(e\in EC(i)\)</span> indicates all the edges surrounding cell <span class="math notranslate nohighlight">\(i\)</span>.
In the TRiSK formulation we assume that the divergence always occurs at the cell center, so the subscript <span class="math notranslate nohighlight">\(i\)</span> is dropped and we simply write  <span class="math notranslate nohighlight">\(\left( \nabla \cdot {\bf F}\right)_i\)</span> as <span class="math notranslate nohighlight">\(\nabla \cdot F_e\)</span>.</p>
<p>The divergence operator above is applied to a general vector field <span class="math notranslate nohighlight">\(\bf F\)</span>.
In the actual formulations below, we substitute the velocity at the edge <span class="math notranslate nohighlight">\(F_e = u_e\)</span> for the divergence variable in the momentum equation, and the thickness-weighted tracer
<span class="math notranslate nohighlight">\(F_e = u_e [h_i \phi_i]_e\)</span>
in the tracer advection term. To be clear, when we refer to the divergence variable, rather than the operator, this means
<div class="math notranslate nohighlight">
\[
\left( \nabla \cdot {\bf u}\right)_i =
D_i
=  \frac{1}{A_i} \sum_{e\in EC(i)} n_{e,i} \, u_e \, l_e.
\]</div>
</p>
</section>
<section id="gradient">
<h4>3.2.2. Gradient<a class="headerlink" href="#gradient" title="Permalink to this heading"></a></h4>
<p>The gradient operator maps a cell-centered scalar to an edge-normal vector component
(<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> eqn 22),</p>
<div class="math notranslate nohighlight">
\[
\left( \nabla h \right)_e
\equiv
\nabla h_i = \frac{1}{d_e} \sum_{i\in CE(e)} -n_{e,i} \, h_i,
\]</div>
<p>where <span class="math notranslate nohighlight">\(i\in CE(e)\)</span> identifies the two cells that neighbor an edge. The edge subscript is dropped, so <span class="math notranslate nohighlight">\(\nabla h_i\)</span> is understood to occur at an edge.</p>
<p>For practical purposes the sign indicator variable <span class="math notranslate nohighlight">\(n_{e,i}\)</span> is not used in the code, and we opt for the simpler formulation
<div class="math notranslate nohighlight">
\[
\left( \nabla h \right)_e
\equiv
\nabla h_i = \frac{h_{i2} - h_{i1} }{d_e},
\]</div>

where <span class="math notranslate nohighlight">\(\left\{i_1, i_2\right\}\)</span> are the cells neighboring edge <span class="math notranslate nohighlight">\(e\)</span>.  The indices <span class="math notranslate nohighlight">\(\left\{i_1, i_2\right\}\)</span> are ordered such that the normal vector <span class="math notranslate nohighlight">\({\bf n}\)</span> points from cell <span class="math notranslate nohighlight">\(i_1\)</span> to cell <span class="math notranslate nohighlight">\(i_2\)</span>. In the code <span class="math notranslate nohighlight">\({\bf n}\)</span> points from <code class="docutils literal notranslate"><span class="pre">CellsOnEdge(IEdge,</span> <span class="pre">0)</span></code> to <code class="docutils literal notranslate"><span class="pre">CellsOnEdge(IEdge,</span> <span class="pre">1)</span></code>.</p>
</section>
<section id="curl">
<h4>3.2.3. Curl<a class="headerlink" href="#curl" title="Permalink to this heading"></a></h4>
<p>The curl operator maps a vector’s edge normal component <span class="math notranslate nohighlight">\(u_e\)</span> to a scalar field at vertex
(<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> eqn 23),</p>
<div class="math notranslate nohighlight">
\[
\left( {\bf k} \cdot \left( \nabla \times {\bf F} \right)\right)_v
\equiv
{\bf k} \cdot \left( \nabla \times F_e \right)
= \frac{1}{{\hat A}_v} \sum_{e\in EV(v)} t_{e,v} \, F_e \, d_e,
\]</div>
<p>where <span class="math notranslate nohighlight">\({\hat A}_v\)</span> is the area of the dual mesh cell <span class="math notranslate nohighlight">\(v\)</span>, i.e. the triangle surrounding vertex <span class="math notranslate nohighlight">\(v\)</span>. Similar to <span class="math notranslate nohighlight">\(n_{e,i}\)</span>, the indicator function <span class="math notranslate nohighlight">\(t_{e,v}\)</span> tracks whether a positive <span class="math notranslate nohighlight">\(F_e\)</span> makes a positive or negative contribution to the curl function at vertex <span class="math notranslate nohighlight">\(v\)</span>. If the vector <span class="math notranslate nohighlight">\({\bf k} \times {\bf n}_e\)</span> is directed toward
<span class="math notranslate nohighlight">\({\bf x}_v\)</span>, then <span class="math notranslate nohighlight">\(t_{e,v}=1\)</span>. The summation is over <span class="math notranslate nohighlight">\(e\in EV(v)\)</span>, which are the edges that terminate at vertex <span class="math notranslate nohighlight">\(v\)</span>. There are <em>always</em> three edges that terminate at each vertex for Voronoi Tessellations, and four edges on each vertex for quadrilateral meshes, unless neighboring cells are missing for land boundaries. Again, the subscript <span class="math notranslate nohighlight">\(v\)</span> is dropped and a vertex is assumed for the location of the curl.</p>
</section>
<section id="perpendicular-vector-component">
<h4>3.2.4. Perpendicular vector component<a class="headerlink" href="#perpendicular-vector-component" title="Permalink to this heading"></a></h4>
<p>The perpendicular component a vector field is defined as
<div class="math notranslate nohighlight">
\[
 {\bf F}^\perp \equiv
 {\bf k} \times {\bf F}
\]</div>

so that it points 90<span class="math notranslate nohighlight">\(^o\)</span> to the left of <span class="math notranslate nohighlight">\({\bf F}\)</span> in a right-handed coordinate system.</p>
<p>In TRiSK, the native component for the prognostic velocity field is the edge-normal velocity <span class="math notranslate nohighlight">\(u_e\)</span>. The perpendicular component is also positioned at the middle of the edge, but points 90<span class="math notranslate nohighlight">\(^o\)</span> to the left, tangential to the edge, from one vertex to another. The perpendicular velocity component is also called the tangential velocity, with the variable name <code class="docutils literal notranslate"><span class="pre">TangentialVelocity</span></code>. It is computed diagnostically as
(<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> eqn 24)</p>
<div class="math notranslate nohighlight">
\[
u_e^\perp = \frac{1}{d_e} \sum_{e'\in ECP(e)} w_{e,e'} \, l_{e'} \, u_{e'}.
\]</div>
<p>The perpendicular vector is computed from the edge-normal components of all the edges of the two neighboring cells of edge <span class="math notranslate nohighlight">\(e\)</span>, denoted as <span class="math notranslate nohighlight">\(e'\in ECP(e)\)</span>. For example, on a mesh with hexagons, there are a total of 10 edges <span class="math notranslate nohighlight">\(e'\)</span> on the two cells neighboring edge <span class="math notranslate nohighlight">\(e\)</span> (the original edge <span class="math notranslate nohighlight">\(e\)</span> is not included).  The tangential velocity <span class="math notranslate nohighlight">\(u_e^\perp\)</span> is used in the Coriolis force, which appears in the potential vorticity advection term.  The weighting coefficients <span class="math notranslate nohighlight">\(w_{e,e'}\)</span> are carefully chosen to conserve potential vorticity, as described in
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109004434">Thuburn et al. 2009</a>
and
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a>.</p>
<p>In the code, the cell indices are ordered such that the edge-normal vector (like <span class="math notranslate nohighlight">\(u_e\)</span>) points positively from the lower to higher cell index value. Likewise, the vertex indices are ordered such that the edge-tangent vector (like <span class="math notranslate nohighlight">\(u_e^\perp\)</span>) points from the lower to higher vertex index value.</p>
<p>In order to reduce redundant operations, the weights in the standard MPAS mesh files are pre-multiplied by the edge length ratio <span class="math notranslate nohighlight">\(l_{e'}/d_e\)</span>. Thus the MPAS variable <code class="docutils literal notranslate"><span class="pre">WeightsOnEdge</span></code> is
<div class="math notranslate nohighlight">
\[
{\tilde w}_{e,e'} = \frac{l_{e'}}{d_e} w_{e,e'}
\]</div>

and the revised calculation of the tangential velocity is
<div class="math notranslate nohighlight">
\[
u_e^\perp = \sum_{e'\in ECP(e)} {\tilde w}_{e,e'} \, u_{e'}.
\]</div>

This simple operation can be seen in MPAS-Ocean in the subroutine <code class="docutils literal notranslate"><span class="pre">ocn_diagnostic_solve_vortVel</span></code> in the file <code class="docutils literal notranslate"><span class="pre">mpas_ocn_diagnostics.F</span></code>.</p>
</section>
<section id="perpendicular-gradient">
<h4>3.2.5. Perpendicular Gradient<a class="headerlink" href="#perpendicular-gradient" title="Permalink to this heading"></a></h4>
<p>The gradient of a scalar at the middle of an edge, pointing tangentially along the edge (from one vertex to the other), is sometimes used. For example, the del2 formulation requires the perpendicular gradient of vorticity. This is called the perpendicular gradient because the standard gradient is normal to the edge.</p>
<p>The perpendicular gradient maps a scalar at vertices to an edge-tangential vector component,
<div class="math notranslate nohighlight">
\[
\left(\nabla \omega_v\right)_e^\perp = \frac{1}{l_e} \sum_{v\in VE(e)} -t_{e,v}\omega_v.
\]</div>

Like the standard gradient, in practice we drop the sign indicator <span class="math notranslate nohighlight">\(t_{e,v}\)</span> and rewrite it using the index ordering,
<div class="math notranslate nohighlight">
\[
\left(\nabla \omega_v\right)_e^\perp = \frac{\omega_{v2} - \omega_{v1}}{l_e},
\]</div>

where the positive vector <span class="math notranslate nohighlight">\({\bf n}^\perp\)</span> is 90<span class="math notranslate nohighlight">\(^o\)</span> to the left of <span class="math notranslate nohighlight">\({\bf n}\)</span>. The indices are ordered such that <span class="math notranslate nohighlight">\({\bf n}^\perp\)</span> points from <span class="math notranslate nohighlight">\(v_1\)</span> to <span class="math notranslate nohighlight">\(v_2\)</span>, which corresponds to <code class="docutils literal notranslate"><span class="pre">VerticesOnEdge(IEdge,</span> <span class="pre">0)</span></code> and <code class="docutils literal notranslate"><span class="pre">VerticesOnEdge(IEdge,</span> <span class="pre">1)</span></code> in the code.</p>
</section>
<section id="cell-to-edge-interpolation">
<h4>3.2.6. Cell to Edge Interpolation<a class="headerlink" href="#cell-to-edge-interpolation" title="Permalink to this heading"></a></h4>
<p>The mid-point average of a scalar from cell centers to the adjoining edge is
<div class="math notranslate nohighlight">
\[
[h_i]_e = \frac{1}{2} \sum_{i\in CE(e)} h_i.
\]</div>

In a Voronoi tessellation the edge is defined to be at the mid-point between the two cell centers, so this formula is identical to an area-weighted average using the triangles between edge <span class="math notranslate nohighlight">\(e\)</span> and the neighboring cell centers.</p>
</section>
<section id="vertex-to-edge-interpolation">
<h4>3.2.7. Vertex to Edge Interpolation<a class="headerlink" href="#vertex-to-edge-interpolation" title="Permalink to this heading"></a></h4>
<p>The mid-point average of a scalar from vertices to the middle of the connecting edge is
<div class="math notranslate nohighlight">
\[
[\omega_v]_e = \frac{1}{2} \sum_{v\in VE(e)} \omega_v.
\]</div>

The is a distance-weighted average, since the edge quantity lives at the mid-point between the vertices. One could alternatively compute an area-weighted average using the dual-mesh cell area <span class="math notranslate nohighlight">\({\hat A}_v\)</span> surrounding each vertex, but that is not done and would result in very small differences.</p>
</section>
<section id="cell-to-vertex-interpolation">
<h4>3.2.8. Cell to Vertex Interpolation<a class="headerlink" href="#cell-to-vertex-interpolation" title="Permalink to this heading"></a></h4>
<p>The area-weighted average of a scalar at a vertex from the three surrounding cells is
<div class="math notranslate nohighlight">
\[
[h_i]_v = \frac{1}{{\hat A}_v} \sum_{i\in CV(v)} h_i {\tilde A}_{v,i}.
\]</div>

Here <span class="math notranslate nohighlight">\({\hat A}_v\)</span> is the dual triangle area centered on the vertex, and <span class="math notranslate nohighlight">\({\tilde A}_{v,i}\)</span> is the area of the kite that extends from <span class="math notranslate nohighlight">\(x_i\)</span> to the vertex <span class="math notranslate nohighlight">\(x_v\)</span>.
The three kites sum to the triangle area,
<div class="math notranslate nohighlight">
\[
{\hat A}_v = \sum_{i\in CV(v)} {\tilde A}_{v,i}.
\]</div>
</p>
</section>
<section id="vertex-to-cell-interpolation">
<h4>3.2.9. Vertex to Cell Interpolation<a class="headerlink" href="#vertex-to-cell-interpolation" title="Permalink to this heading"></a></h4>
<p>The area-weighted average of a scalar at a cell from the surrounding vertices is
<div class="math notranslate nohighlight">
\[
[h_v]_i = \frac{1}{A_i} \sum_{v\in VC(i)} h_v {\tilde A}_{v,i}
\]</div>
</p>
</section>
<section id="vector-from-edge-to-cell">
<h4>3.2.10. Vector from Edge to Cell<a class="headerlink" href="#vector-from-edge-to-cell" title="Permalink to this heading"></a></h4>
<p>The prognostic velocity variable on the edge is the edge normal velocity, <span class="math notranslate nohighlight">\(u_e\)</span>. The tangential velocity <span class="math notranslate nohighlight">\(u_e^\perp\)</span> is computed diagnostically from <span class="math notranslate nohighlight">\(u_e\)</span>. In addition, the full vector may be computed at the cell center from the edge normal velocities <span class="math notranslate nohighlight">\(u_e\)</span> of the edges on that cell. That is done in MPAS with radial basis functions, and is explained in this <a class="reference external" href="https://github.com/MPAS-Dev/MPAS-Documents/blob/master/shared/rbf_design/rbf.pdf">previous design document</a>.</p>
</section>
</section>
<section id="momentum-terms">
<h3>3.3 Momentum Terms<a class="headerlink" href="#momentum-terms" title="Permalink to this heading"></a></h3>
<p>The computation of each term in (4-6) is now described in detail, along with alternative formulations.</p>
<section id="kinetic-energy-gradient">
<h4>3.3.1. Kinetic energy gradient<a class="headerlink" href="#kinetic-energy-gradient" title="Permalink to this heading"></a></h4>
<p>The kinetic energy gradient term is the non-rotational part of the nonlinear advection. Fundamentally, it maps the prognostic edge-normal velocity from edges back to an edge scalar quantity. We use the standard gradient formulation from cell center to edge,</p>
<div class="math notranslate nohighlight">
\[
\nabla K_i = \frac{1}{d_e} \sum_{i\in CE(e)} -n_{e,i}K_i.
\]</div>
<p>There are several methods to compute the cell-centered kinetic energy. The first uses the edge-normal velocities as in
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> equation 63,</p>
<div class="math notranslate nohighlight">
\[
K_i = \frac{1}{A_i} \sum_{e\in EC(i)} \frac{{\bar A}_{e}}{4}u_e^2.
\]</div>
<p>Here <span class="math notranslate nohighlight">\({\bar A}_{e}\)</span> is the rectangle about the edge defined by <span class="math notranslate nohighlight">\({\bar A}_{e} = l_e d_e\)</span> so that
<div class="math notranslate nohighlight">
\[
A_i = \sum_{e\in EC(i)} \frac{{\bar A}_{e}}{4}
\]</div>

as stated in
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999109006780">Ringler et al. 2010</a> equations 48, 64, and footnote 4.</p>
<p>One might expect an additional factor of one-half in the <span class="math notranslate nohighlight">\(K_i\)</span> formula, as in the standard formula for kinetic energy, <span class="math notranslate nohighlight">\(K = \tfrac{1}{2} m v^2\)</span>. However, the one-half is missing because <span class="math notranslate nohighlight">\(u_e\)</span> is only one component of the velocity vector on the edge. One could replace <span class="math notranslate nohighlight">\(u_e^2\)</span> with <span class="math notranslate nohighlight">\(\tfrac{1}{2}(u_e^2 + {u_e^{\perp}}^2)\)</span>, but <span class="math notranslate nohighlight">\(u^\perp_e\)</span> is already computed from the surrounding values of <span class="math notranslate nohighlight">\(u_e\)</span>, so we don’t do that because it would just add redundant information. As a side note, the mass <span class="math notranslate nohighlight">\(m\)</span> is missing because the mass is already divided out of the momentum equation (1).</p>
<p>The kinetic energy may also be computed at the vertex.  This uses the velocity on the three connected edges,
<div class="math notranslate nohighlight">
\[
K_v = \frac{1}{{\hat A}_{v}} \sum_{e\in EV(v)} \frac{{\bar A}_{e}}{4}u_e^2.
\]</div>

Note that this normalization works because
<div class="math notranslate nohighlight">
\[
{\hat A}_{v} = \sum_{e\in EV(v)} \frac{{\bar A}_{e}}{4},
\]</div>

since <span class="math notranslate nohighlight">\({\bar A}_{e}/4\)</span> is exactly the portion of the triangle contributed to <span class="math notranslate nohighlight">\({\hat A}_{v}\)</span> by each edge.</p>
<p>The computation of <span class="math notranslate nohighlight">\(K_v\)</span> can be found in the MPAS-Ocean code with the <code class="docutils literal notranslate"><span class="pre">kineticEnergyVertex</span></code> variable. The final kinetic energy at the cell center may be chosen to be either <span class="math notranslate nohighlight">\(K_i\)</span> in the first equation above, or a linear combination of <span class="math notranslate nohighlight">\(K_i\)</span> and <span class="math notranslate nohighlight">\(K_v\)</span> interpolated to cell centers. In MPAS-Ocean, the flag <code class="docutils literal notranslate"><span class="pre">config_include_KE_vertex</span></code> uses the value</p>
<div class="math notranslate nohighlight">
\[
\frac{5}{8} K_i + \frac{3}{8} [K_v]_i
\]</div>
<p>for the final kinetic energy at the cell center. Note that addition of <span class="math notranslate nohighlight">\([K_v]_i\)</span> enlarges the stencil. One could also use <span class="math notranslate nohighlight">\(u_e^{\perp}\)</span> and compute the kinetic energy at the edge itself in order to enlarge the stencil, but that method is not used here.
See <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S146350032100161X">Calandrini et al. 2021</a> section 2.3 for more information.</p>
</section>
<section id="potential-vorticity-term">
<h4>3.3.2. Potential vorticity term<a class="headerlink" href="#potential-vorticity-term" title="Permalink to this heading"></a></h4>
<p>The potential vorticity term, <span class="math notranslate nohighlight">\(q\left(h\boldsymbol{u}^{\perp}\right)\)</span>, includes the rotational part of the advection. It may be computed in two ways,</p>
<div class="math notranslate nohighlight">
\[
\text{Option 1:  } \left[ \frac{\omega_v +f_v}{[h_i]_v}\right]_e\left([h_i]_e u_e^{\perp}\right)
\]</div>
<div class="math notranslate nohighlight">
\[
\text{Option 2:  }([\omega_v]_e +f_e) u_e^\perp
\]</div>
<p>The first computes the potential vorticity <span class="math notranslate nohighlight">\(q_v\)</span> at the vertex and interpolates that quantity to the edge, which is what is done in MPAS-Ocean. One may also cancel the thickness <span class="math notranslate nohighlight">\(h\)</span> (ignoring the interpolated locations) and use option 2. Additional interpolation options and results are presented in <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S146350032100161X">Calandrini et al. 2021</a></p>
</section>
<section id="sea-surface-height-gradient">
<h4>3.3.3. Sea surface height gradient<a class="headerlink" href="#sea-surface-height-gradient" title="Permalink to this heading"></a></h4>
<p>The sea surface height (SSH) gradient uses the standard gradient formulation from cell center to edge,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
-g\nabla(h_i-b_i) &amp;= -g\frac{1}{d_e} \sum_{i\in CE(e)} -n_{e,i}(h_i-b_i)\\
&amp;= -g\frac{(h_{i2}-b_{i2}) - (h_{i1}-b_{i1}) }{d_e}.
\end{split}\]</div>
</section>
<section id="del2-momentum-dissipation">
<h4>3.3.4. Del2 momentum dissipation<a class="headerlink" href="#del2-momentum-dissipation" title="Permalink to this heading"></a></h4>
<p>The Del2, or Laplacian operator, viscous momentum dissipation maps edge-normal velocity back to the edge-normal component of the Laplacian. In TRiSK this is done with the vorticity-divergence formulation, which may be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\nabla^2 {\bf u} &amp;=  \nabla \left( \nabla\cdot{\bf u}\right) - \nabla \times \left( \nabla \times {\bf u} \right) \\
 &amp;=  \nabla {\bf D} - \nabla \times \omega \\
 &amp;=  \nabla {\bf D} - {\bf k} \times \nabla \omega \\
 &amp;=  \nabla {\bf D} - \nabla^\perp \omega.
\end{split}\]</div>
<p>This formulation is also mentioned in <a class="reference external" href="https://linkinghub.elsevier.com/retrieve/pii/S0021999111000325">Gassmann 2011</a> (equation 17), <a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1002/qj.3294">Gassman 2018</a> (equation 44) and <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1463500324000222">Lapolli et al. 2024</a> (section 4.5.2).</p>
<p>For our discretization, the full Del2 term is written as
<div class="math notranslate nohighlight">
\[\begin{split}
\nu_2 \nabla^2 u_e &amp;= \nu_2 \left( \nabla D_i - \nabla^\perp \omega_v\right) \\
&amp;= \nu_2 \left( \frac{1}{d_e} \sum_{i\in CE(e)} -n_{e,i}D_i - \frac{1}{l_e} \sum_{v\in VE(e)} -t_{e,v}\omega_v\right) \\
&amp;= \nu_2 \left( \frac{D_{i2} - D_{i1}}{d_e} - \frac{\omega_{v2} - \omega_{v1}}{l_e} \right),
\end{split}\]</div>

where the ordering of indices <span class="math notranslate nohighlight">\(\{i_i, i_2\}\)</span> and <span class="math notranslate nohighlight">\(\{v_1, v_2\}\)</span> are explained in the gradient operator sections above.</p>
<p>An alternative formulation for the Del2 dissipation on an unstructured mesh is presented in section 4.2 and Appendix B of
<a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1002/qj.3294">Gassman 2018</a>.</p>
</section>
<section id="del4-momentum-dissipation">
<h4>3.3.5. Del4 momentum dissipation<a class="headerlink" href="#del4-momentum-dissipation" title="Permalink to this heading"></a></h4>
<p>The Del4, or biharmonic, momentum dissipation also maps edge-normal velocity back to the edge-normal component of the Laplacian. This is done with two applications of the Del2 operator above.</p>
<div class="math notranslate nohighlight">
\[
- \nu_4 \nabla^4 u_e = - \nu_4 \nabla^2 \left( \nabla^2 u_e \right)
\]</div>
</section>
<section id="rayleigh-drag">
<h4>3.3.6. Rayleigh Drag<a class="headerlink" href="#rayleigh-drag" title="Permalink to this heading"></a></h4>
<p>Rayleigh drag is simply linear drag, applied to all levels. It is typically only used during the spin-up process to damp large velocities during the initial adjustment. The Rayleigh coefficient <span class="math notranslate nohighlight">\(Ra\)</span> is simply a scalar constant,</p>
<div class="math notranslate nohighlight">
\[
- Ra \: u_e.
\]</div>
</section>
<section id="bottom-drag">
<h4>3.3.7. Bottom drag<a class="headerlink" href="#bottom-drag" title="Permalink to this heading"></a></h4>
<p>Bottom drag is more relevant to layered models than to shallow water systems, but is included here for completeness. It is a quadratic drag applied to the edge velocity,</p>
<div class="math notranslate nohighlight">
\[
- C_D \frac{u_e\left|u_e\right|}{[h_i]_e}.
\]</div>
</section>
<section id="wind-forcing">
<h4>3.3.8. Wind forcing<a class="headerlink" href="#wind-forcing" title="Permalink to this heading"></a></h4>
<p>Wind forcing has the same form as the bottom drag, but the forcing is the difference between the current velocity and the wind <span class="math notranslate nohighlight">\(u_W\)</span>, interpolated and projected to the edge normal direction,</p>
<div class="math notranslate nohighlight">
\[
- C_W \frac{(u_W - u_e)\left|u_W - u_e\right|}{[h_i]_e}.
\]</div>
</section>
</section>
<section id="thickness-and-tracer-terms">
<h3>3.4 Thickness and Tracer Terms<a class="headerlink" href="#thickness-and-tracer-terms" title="Permalink to this heading"></a></h3>
<section id="tracer-advection">
<h4>3.4.1. Tracer advection<a class="headerlink" href="#tracer-advection" title="Permalink to this heading"></a></h4>
<p>There are many schemes available for tracer advection. Simple schemes include centered advection and upstream. MPAS-Ocean uses Flux Corrected Transport, which is fourth order under normal conditions, and reduces to third order to preserve monotonicity.</p>
<p>The tracer advection term is
<div class="math notranslate nohighlight">
\[
\nabla \cdot \left(u_e [h_i \phi_i]_e \right)
\]</div>
</p>
<p>and the stencil for divergence makes this
<div class="math notranslate nohighlight">
\[
\nabla \cdot \left( u_e [h_i \phi_i]_e \right)  =  \frac{1}{A_i} \sum_{e\in EC(i)} n_{e,i}u_e [h_i \phi_i]_e l_e.
\]</div>

The question is how to interpolate to the edge to obtain <span class="math notranslate nohighlight">\([h_i \phi_i]_e\)</span>. Centered advection simply uses the midpoint rule. Upwind takes the value from the upstream cell. Higher order schemes cast a wider stencil to compute the value at this edge. This includes Flux Corrected Transport, used in MPAS-Ocean, and described in <a class="reference external" href="https://journals.ametsoc.org/view/journals/mwre/139/9/mwr-d-10-05056.1.xml">Skamarock and Gassmann 2011</a>.</p>
<p>Note that the thickness advection is identical to the tracer advection when <span class="math notranslate nohighlight">\(\phi\)</span> is uniformly one. Thus the same algorithm may be used for both. In fact, this is required for global conservation of tracers, so that the volume flux and tracer flux across each edge are consistent.</p>
<p>More details of the tracer advection scheme will be given in a future design document.</p>
</section>
<section id="del2-tracer-diffusion">
<h4>3.4.2. Del2 tracer diffusion<a class="headerlink" href="#del2-tracer-diffusion" title="Permalink to this heading"></a></h4>
<p>Tracer diffusion is applied with a Laplacian operator on the cell-centered tracer phi, and the product of the operator is also at the cell center. The Laplacian may be written as the divergence of the gradient,</p>
<div class="math notranslate nohighlight">
\[
\kappa_2 h_i \nabla^2 \phi_i
=
\kappa_2 h_i \nabla \cdot \left( \nabla \phi_i \right).
\]</div>
<p>and the stencils in Section 3.2 are used. Here <span class="math notranslate nohighlight">\(\kappa_2\)</span> is the del2 diffusion coefficient, and the operator is thickness-weighted by <span class="math notranslate nohighlight">\(h_i\)</span>. The position of a gradient is assumed to be at an edge, and a divergence at the cell center. This could be written explicitly as</p>
<div class="math notranslate nohighlight">
\[
\kappa_2 h_i \left( \nabla^2 \phi_i \right)_i
=
\kappa_2 h_i \left( \nabla \cdot \left( \nabla \phi_i \right)_e \right)_i.
\]</div>
</section>
<section id="del4-tracer-diffusion">
<h4>3.4.3. Del4 tracer diffusion<a class="headerlink" href="#del4-tracer-diffusion" title="Permalink to this heading"></a></h4>
<p>The del4 tracer diffusion is simply the Laplacian operator applied twice,</p>
<div class="math notranslate nohighlight">
\[
- \kappa_4 h_i \nabla^4 \phi_i
=
- \kappa_4 h_i \nabla^2 \left( \nabla^2 \phi_i \right).
\]</div>
<p>The del2 operator using the divergence of the gradient in the last section is used, with the simple stencils from Section 3.2.</p>
</section>
</section>
</section>
<section id="design">
<h2>4 Design<a class="headerlink" href="#design" title="Permalink to this heading"></a></h2>
<p>The design details may be found in other design documents, such as those for the state, auxiliary variables, and tendency terms.</p>
<!-- To do in later PR: Add all design details.

1. Index ordering will be: (time, tracer, horizontal index, vertical index) Note this is c-style indexing, with last index being fastest, i.e. contiguous in memory.
2. Time stepping will be multi-level, with an arbitrary number of levels for multistage methods. -->
<!-- You can include code blocks like this: -->
<!--  -->
<!-- ```c++ -->
<!-- // int var = value; -->
<!-- ``` -->
<!--  -->
<!-- ### 4.1 Data types and parameters -->
<!--  -->
<!-- #### 4.1.1 Parameters -->
<!--  -->
<!-- to do: List and define any configuration parameters or public constants. -->
<!--  -->
<!-- #### 4.1.2 Class/structs/data types -->
<!--  -->
<!-- to do: Describe any public data types and/or the class definition -->
<!--  -->
<!-- ### 4.2 Methods -->
<!--  -->
<!-- to do: List and describe all public methods and their interfaces (actual code for  -->
<!-- interface that would be in header file). Describe typical use cases. -->
</section>
<section id="verification-and-testing">
<h2>5 Verification and Testing<a class="headerlink" href="#verification-and-testing" title="Permalink to this heading"></a></h2>
<section id="convergence-of-individual-terms">
<h3>5.1 Convergence of individual terms<a class="headerlink" href="#convergence-of-individual-terms" title="Permalink to this heading"></a></h3>
<p>The following terms can be tested with sine waves on periodic domains on a cartesian regular-hexagon mesh, as described in <a class="reference external" href="https://doi.org/10.1029/2022MS003545">Bishnu et al. 2024</a> and <a class="reference external" href="https://doi.org/10.5281/zenodo.7439539">Bishnu et al. 2021</a>.</p>
<ol class="arabic simple">
<li><p>Divergence operator at cell centers (2nd order)</p></li>
<li><p>Gradient operator normal to edges (2nd order)</p></li>
<li><p>Curl operator at vertices, i.e. vorticity from a vector field (1st order)</p></li>
<li><p>Curl operator interpolated to cell centers (2nd order)</p></li>
<li><p>Tangential velocity at edges, computed from normal velocity (2nd order)</p></li>
</ol>
<p>Requirements for tests are:</p>
<ul class="simple">
<li><p>compares order of convergence against an expected threshold</p></li>
</ul>
<p>These tests can be conducted at the earliest stages of dycore development, in tandem with the implementation of each operator. In the longer term, these tests will be subsumed by the inertia gravity wave, which tests the order of convergence of all these operators together.</p>
<p>Operator convergence tests may additionally be conducted on the sphere using spherical harmonics for the analytic solution. This was conducted on MPAS-Ocean by Hyun Kang in 2023.</p>
</section>
<section id="inertia-gravity-wave-linearized-shallow-water-no-tracers">
<h3>5.2 Inertia Gravity Wave: linearized shallow water, no tracers<a class="headerlink" href="#inertia-gravity-wave-linearized-shallow-water-no-tracers" title="Permalink to this heading"></a></h3>
<p>The inertia gravity wave test provides an exact solution in time for the linearized shallow water equations (momentum and thickness). It tests the time stepping scheme along with the linearized advection terms, the SSH gradient. It does not test diffusive terms or bottom drag. It is conducted on a doubly periodic cartesian mesh, so does not test boundary conditions. The numerical solution should converge to the analytic solution at 2nd order, as shown in <a class="reference external" href="https://doi.org/10.1029/2022MS003545">Bishnu et al. 2024</a>, Section 2.6, Figures 11 and 15. Also see the inertia gravity test case in Polaris.</p>
<p>Requirements for tests are:</p>
<ul class="simple">
<li><p>expected order of convergence</p></li>
<li><p>conservation of total volume</p></li>
<li><p>automation and reproducibility in polaris</p></li>
</ul>
<p>This test should be conducted as soon as momentum and thickness equations and time-stepping is in place. It does not require any tracer infrastructure.</p>
</section>
<section id="manufactured-solution-full-nonlinear-shallow-water-no-tracers">
<h3>5.3 Manufactured Solution: full nonlinear shallow water, no tracers<a class="headerlink" href="#manufactured-solution-full-nonlinear-shallow-water-no-tracers" title="Permalink to this heading"></a></h3>
<p>The manufactured solution test provides an exact solution in time for the full nonlinear shallow water equations (momentum and thickness). It tests the time stepping scheme along with the full advection terms and the SSH gradient.  It is conducted on a doubly periodic cartesian mesh, so does not test boundary conditions. Error should converge at 2nd order, as shown in <a class="reference external" href="https://doi.org/10.1029/2022MS003545">Bishnu et al. 2024</a>, Section 2.10 and Figures 13 and 19. Also see the manufactured solution test case in Polaris.</p>
<p>Requirements for tests are:</p>
<ul class="simple">
<li><p>expected order of convergence</p></li>
<li><p>conservation of total volume</p></li>
<li><p>automation and reproducibility in polaris</p></li>
</ul>
<p>This test should be conducted as soon as momentum and thickness equations and time-stepping is in place. It does not require any tracer infrastructure.</p>
</section>
<section id="tracer-transport-on-a-sphere">
<h3>5.4 Tracer transport on a sphere<a class="headerlink" href="#tracer-transport-on-a-sphere" title="Permalink to this heading"></a></h3>
<p>A test suite will be used to test horizontal transport schemes on the sphere comprised of test case 1 from <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999105800166">Williamson et al. (1992)</a> and several tests from <a class="reference external" href="https://www.geosci-model-dev.net/5/887/2012/">Lauritzen et al. (2012)</a>.
They test the tracer advection and tracer time stepping. Velocity and thickness are predefined fields and remain fixed, so this does not exercise those equations.</p>
<p>Requirements for tests are:</p>
<ul class="simple">
<li><p>compares order of convergence against an expected threshold</p></li>
<li><p>conservation of total tracer amount</p></li>
<li><p>produces visualization that allows the user to evaluate whether numerical mixing resembles real mixing (preserves functional relationships between tracers)</p></li>
<li><p>tracer min and max values should remain bounded by initial bounds.</p></li>
<li><p>automation and reproducibility in polaris</p></li>
</ul>
</section>
<section id="performance-testing">
<h3>5.5 Performance testing<a class="headerlink" href="#performance-testing" title="Permalink to this heading"></a></h3>
<p>Tests can be conducted with inertia-gravity wave tests but with full non-linear terms and 100 identical layers. Domain will be cartesian resolutions from 64x64 up to 512x512. See performance test results using MPAS-Ocean on Perlmutter, using this setup, in <a class="reference external" href="https://gmd.copernicus.org/articles/16/5539/2023">Bishnu et al. 2023</a>. Additionally, we could test spherical cases with a Williamson test case or similar.</p>
<p>Requirements for tests are:</p>
<ul class="simple">
<li><p>Single CPU performance should be as good or better than single CPU MPAS-Ocean.</p></li>
<li><p>GPU tests on single node should be better than single node CPU tests.</p></li>
<li><p>Scaling on CPUs multi-node, up to 4096 cores or higher, should be close to perfect scaling for 512x512 mesh, and as good or better than MPAS-Ocean.</p></li>
<li><p>Scaling on GPUs for multi-node should be close to perfect scaling for 512x512 mesh.</p></li>
<li><p>automation and reproducibility in polaris</p></li>
</ul>
</section>
<section id="shallow-water-tests-on-spherical-domains-and-with-realistic-coastlines">
<h3>5.6 Shallow water tests on spherical domains and with realistic coastlines<a class="headerlink" href="#shallow-water-tests-on-spherical-domains-and-with-realistic-coastlines" title="Permalink to this heading"></a></h3>
<p>Global cases will facilitate the testing of shallow water dynamics on the sphere and of boundary conditions with realistic coastlines, which are not included in any of the previous tests. This includes testing conservation of volume and tracers in global domains.</p>
<p>Potential test cases include:</p>
<ol class="arabic simple">
<li><p>Surface gravity wave: The speed of the surface gravity wave can be compared to the theoretical expectation, as shown in <a class="reference external" href="https://gmd.copernicus.org/articles/16/1297/2023">Pal et al. 2023</a> Appendix A. This could use an aquaplanet domain (flat bottom, no coastlines) to measure the gravity wave speed, and a realistic domain to test boundary conditions and variable-depth bathymetry.</p></li>
<li><p>Stommel double gyre:  This may be compared to an exact solution in the Cartesian case, as in <a class="reference external" href="https://gmd.copernicus.org/articles/16/1297/2023">Pal et al. 2023</a> Appendix B, or qualitative comparisons for the spherical case using either idealized boundaries or an isolated Atlantic Basin domain.</p></li>
</ol>
<p>Tests of realistic global circulation cannot be done with the shallow water equations of Omega-0, but will be part of Omega-1 development with the layered primitive equation model.</p>
</section>
<section id="further-tests-for-omega-0">
<h3>5.7 Further tests for Omega-0<a class="headerlink" href="#further-tests-for-omega-0" title="Permalink to this heading"></a></h3>
<p>Potential additional test cases include the following. These are useful to explore and validate model behavior, but are optional, depending on the time available.</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0021999105800166">Williamson et al. 1992</a> as test case 2 or 3, global steady state solutions.</p></li>
<li><p>Global case with unstable jet <a class="reference external" href="https://doi.org/10.3402/tellusa.v56i5.14436">Galewsky et al. 2003</a></p></li>
</ol>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading"></a></h2>
<p>Cushman‐Roisin, B., &amp; Beckers, J.‐M. (2011). Introduction to geophysical fluid dynamics: Physical and numerical aspects. Academic press.</p>
<p>Gill, A. E. (2016). Atmosphere—Ocean dynamics. Elsevier.</p>
<p>Pedlosky, J. (1987). Geophysical fluid dynamics (Vol. 710). Springer.</p>
<p>Vallis, G. K. (2017). Atmospheric and oceanic fluid dynamics. Cambridge University Press.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../devGuide/Tracers.html" class="btn btn-neutral float-left" title="Tracers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Broadcast.html" class="btn btn-neutral float-right" title="Broadcast" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Energy Exascale Earth System Model Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>