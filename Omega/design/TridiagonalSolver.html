

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tridiagonal Solver &mdash; Omega develop documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
      <script src="../_static/jquery.js"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/doctools.js"></script>
      <script src="../_static/sphinx_highlight.js"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Vertical Mixing Coefficients" href="VerticalMixingCoeff.html" />
    <link rel="prev" title="Tracer Infrastructure" href="Tracers.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Omega
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/QuickStart.html">Quick Start for Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OmegaBuild.html">CMake-based Omega Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Logging.html">Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Dimension.html">Dimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Error.html">Error handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Field.html">Fields and Metadata (Field)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/IOStreams.html">IO Streams (IOStream)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/AuxiliaryState.html">Auxiliary State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/OceanState.html">Ocean State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TimeStepping.html">Time stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/Tracers.html">Tracers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userGuide/TridiagonalSolvers.html">Tridiagonal Solvers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer's guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/QuickStart.html">Quick Start for Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/CondaEnv.html">Development Conda Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Linting.html">Linting Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/BuildDocs.html">Building the Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/DataTypes.html">Data Types and Precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/DataTypes.html#arrays-and-kokkos">Arrays and Kokkos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/MachEnv.html">Machine Environment (MachEnv)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Config.html">Model Configuration (Config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Driver.html">Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Broadcast.html">Omega Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/CMakeBuild.html">Omega Build with CMake</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Logging.html">Developing Omega Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Decomp.html">Domain Decomposition (Decomp)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Dimension.html">Dimension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Error.html">Error Handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Field.html">Fields and Metadata (Field)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/IO.html">Parallel IO (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/IOStreams.html">IO Streams (IOStream)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Halo.html">Halo Exchanges (Halo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/HorzMesh.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/HorzOperators.html">Horizontal Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/AuxiliaryVariables.html">Auxiliary Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/AuxiliaryState.html">Auxiliary State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TendencyTerms.html">Tendency Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/OceanState.html">Ocean State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TimeMgr.html">Time Manager (TimeMgr)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TimeStepping.html">Time stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/Tracers.html">Tracers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devGuide/TridiagonalSolvers.html">Tridiagonal Solvers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Design documents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="OmegaV0ShallowWater.html">Omega V0: Shallow Water</a></li>
<li class="toctree-l1"><a class="reference internal" href="Broadcast.html">Broadcast</a></li>
<li class="toctree-l1"><a class="reference internal" href="Config.html">Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataTypes.html">DataTypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Decomp.html">Decomp</a></li>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">Driver and Component Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="EOS.html">Equation of State</a></li>
<li class="toctree-l1"><a class="reference internal" href="Error.html">ErrorHandler (Error)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Halo.html">Halo</a></li>
<li class="toctree-l1"><a class="reference internal" href="HorzMeshClass.html">Horizontal Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="MachEnv.html">MachineEnv</a></li>
<li class="toctree-l1"><a class="reference internal" href="Metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO.html">Input/Output (IO)</a></li>
<li class="toctree-l1"><a class="reference internal" href="IOStreams.html">IOStreams</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reductions.html">Global Reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="State.html">State</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tendency.html">Tendency</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tendencies.html">Tendencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="AuxiliaryVariables.html">Auxiliary variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="AuxiliaryState.html">AuxiliaryState</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeMgr.html">TimeManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timers.html">Timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepping.html">Time Stepping</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tracers.html">Tracer Infrastructure</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tridiagonal Solver</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">1 Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#requirements">2 Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirement-modularity">2.1 Requirement: Modularity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-stability-for-vertical-mixing-problems">2.2 Requirement: Stability for vertical mixing problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-top-and-bottom-boundary-conditions">2.3 Requirement: Top and bottom boundary conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requirement-performance">2.4 Requirement: Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#desired-ability-to-fuse-kernels">2.5 Desired: Ability to fuse kernels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algorithmic-formulation">3 Algorithmic Formulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thomas-algorithm">3.1 Thomas algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parallel-cyclic-reduction">3.2 (Parallel) cyclic reduction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#design">4 Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-types-and-parameters">4.1 Data types and parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parameters">4.1.1 Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-structs-data-types">4.1.2 Class/structs/data types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scratch-data-structs">4.1.2.1 Scratch data structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#solver-structs">4.1.2.2 Solver structs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#methods">4.2 Methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scratch-constructors">4.2.1 Scratch Constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#policy-creation">4.2.2 Policy creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#solve-methods">4.2.3 Solve Methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#verification-and-testing">5 Verification and Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#test-solvers-correctness-using-prescribed-matrix">5.1 Test solvers correctness using prescribed matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-diffusion-solvers-convergence-using-manufactured-solution">5.2 Test diffusion solvers convergence using manufactured solution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-stability">5.3 Test stability</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="VerticalMixingCoeff.html">Vertical Mixing Coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="Template.html">Template</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Omega</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tridiagonal Solver</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/design/TridiagonalSolver.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="tridiagonal-solver">
<h1>Tridiagonal Solver<a class="headerlink" href="#tridiagonal-solver" title="Permalink to this heading"></a></h1>
<!--- use table of contents if desired for longer documents  -->
<p><strong>Table of Contents</strong></p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#overview">Overview</a></p></li>
<li><p><a class="reference internal" href="#requirements">Requirements</a></p></li>
<li><p><a class="reference internal" href="#algorithmic-formulation">Algorithmic Formulation</a></p></li>
<li><p><a class="reference internal" href="#design">Design</a></p></li>
<li><p><a class="reference internal" href="#verification-and-testing">Verification and Testing</a></p></li>
</ol>
<section id="overview">
<h2>1 Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>In geophysical models, implicit time integration of vertical terms often requires solution to tridiagonal systems of equations.
Typically, a separate system needs to be solved in each vertical column, which requires an efficient batched tridiagonal solver.
One common situation where a tridiagonal system arises is implicit treatment of vertical diffusion/mixing.
In principle, this problem results in a symmetric diagonally-dominant tridiagonal system.
However, in ocean modeling, the coefficients of vertical mixing can vary by orders of magnitude and
can become very large in some layers.
This requires specialized algorithms that can handle this situation stably.</p>
</section>
<section id="requirements">
<h2>2 Requirements<a class="headerlink" href="#requirements" title="Permalink to this heading"></a></h2>
<section id="requirement-modularity">
<h3>2.1 Requirement: Modularity<a class="headerlink" href="#requirement-modularity" title="Permalink to this heading"></a></h3>
<p>There should be one module that provides tridiagonal solvers that are sufficiently general to handle every need in Omega.</p>
</section>
<section id="requirement-stability-for-vertical-mixing-problems">
<h3>2.2 Requirement: Stability for vertical mixing problems<a class="headerlink" href="#requirement-stability-for-vertical-mixing-problems" title="Permalink to this heading"></a></h3>
<p>A specialized solver that is stable for vertical mixing problems with large variations in mixing coefficients must be
provided.</p>
</section>
<section id="requirement-top-and-bottom-boundary-conditions">
<h3>2.3 Requirement: Top and bottom boundary conditions<a class="headerlink" href="#requirement-top-and-bottom-boundary-conditions" title="Permalink to this heading"></a></h3>
<p>When applied to the implicit vertical mixing of momentum, the specialized diffusion solver should be
sufficiently general to be able to incorporate various bottom drag and wind stress formulations.</p>
</section>
<section id="requirement-performance">
<h3>2.4 Requirement: Performance<a class="headerlink" href="#requirement-performance" title="Permalink to this heading"></a></h3>
<p>All solvers must be performant on CPU and GPU architectures. On CPUs this means supporting vectorization.</p>
</section>
<section id="desired-ability-to-fuse-kernels">
<h3>2.5 Desired: Ability to fuse kernels<a class="headerlink" href="#desired-ability-to-fuse-kernels" title="Permalink to this heading"></a></h3>
<p>Implicit vertical mixing will require some pre-processing (e.g. setup of the system) and post-processing work.
It is desirable to handle all of that in one computational kernel. This requires the ability to call the
solvers inside a <code class="docutils literal notranslate"><span class="pre">parallelFor</span></code>.</p>
</section>
</section>
<section id="algorithmic-formulation">
<h2>3 Algorithmic Formulation<a class="headerlink" href="#algorithmic-formulation" title="Permalink to this heading"></a></h2>
<p>A general tridiagonal system has the form:
<div class="math notranslate nohighlight">
\[
a_i x_{i - 1} + b_i x_i + c_i x_{i + 1} = y_i.
\]</div>

The standard second-order discretization of a diffusion problem leads to a system of the form
<div class="math notranslate nohighlight">
\[
-g_{i - 1} x_{i - 1} + (g_{i - 1} + g_i + h_i) x_i - g_{i} x_{i + 1} = y_i,
\]</div>

where <span class="math notranslate nohighlight">\(g_i\)</span>, <span class="math notranslate nohighlight">\(h_i\)</span> are positive and <span class="math notranslate nohighlight">\(g_i\)</span> is proportional to the mixing coefficient
and can be much greater than <span class="math notranslate nohighlight">\(h_i\)</span>, which is the layer thickness.</p>
<section id="thomas-algorithm">
<h3>3.1 Thomas algorithm<a class="headerlink" href="#thomas-algorithm" title="Permalink to this heading"></a></h3>
<p>The Thomas algorithm is a simplified form of Gaussian elimination for tridiagonal systems of equations.
In its typical implementation, the forward elimination phase proceeds as follows
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
c'_i &amp;= \frac{c_i}{b_i - a_i c'_{i - 1}}, \\
y'_i &amp;= \frac{y_i - a_i y'_{i - 1}}{b_i - a_i c'_{i - 1}}.
\end{aligned}
\end{split}\]</div>

When applied to the diffusion system this leads to
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
c'_i &amp;= \frac{-g_i}{h_i + g_{i - 1} (1 + c'_{i - 1}) + g_{i}}, \\
y'_i &amp;= \frac{y_i + g_{i - 1} y'_{i - 1}}{h_i + g_{i - 1} (1 + c'_{i - 1}) + g_i}.
\end{aligned}
\end{split}\]</div>

Let’s consider what happens when the mixing coefficient, and hence <span class="math notranslate nohighlight">\(g_i\)</span>, abruptly changes.
Suppose that <span class="math notranslate nohighlight">\(h_i\)</span> is small, <span class="math notranslate nohighlight">\(g_{i - 1}\)</span> is small, but <span class="math notranslate nohighlight">\(g_i\)</span> is very large.
Then <span class="math notranslate nohighlight">\(c'_i \approx -1\)</span> and in the next iteration the term <span class="math notranslate nohighlight">\(g_i (1 + c'_i)\)</span> in
the denominator of both expression will multiply a very small number by a very large number.</p>
<p>Following <a class="reference external" href="https://journals.ametsoc.org/view/journals/mwre/123/9/1520-0493_1995_123_2839_argiom_2_0_co_2.xml">Appendix E in Schopf and Loughe</a>, to remedy that we can introduce
<div class="math notranslate nohighlight">
\[
\alpha'_i = g_i (1 + c'_i),
\]</div>

which satisfies the following recursion relation
<div class="math notranslate nohighlight">
\[
\alpha'_i = \frac{g_i (h_i + \alpha'_{i - 1})}{h_i + \alpha'_{i - 1} + g_i}.
\]</div>

The above equation together with
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
c'_i &amp;= \frac{-g_i}{h_i + \alpha'_{i - 1} + g_{i}}, \\
y'_i &amp;= \frac{y_i + g_{i - 1} y'_{i - 1}}{h_i + \alpha'_{i - 1} + g_i},
\end{aligned}
\end{split}\]</div>

forms the modifed stable algorithm.</p>
</section>
<section id="parallel-cyclic-reduction">
<h3>3.2 (Parallel) cyclic reduction<a class="headerlink" href="#parallel-cyclic-reduction" title="Permalink to this heading"></a></h3>
<p>The Thomas algorithm is work-efficient, but inherently serial.
While systems in different columns can
be solved in parallel, this might not expose enough parallelism on modern GPUs.
There are parallel tridiagonal algorithms that perform better on modern GPUs,
see <a class="reference external" href="https://doi.org/10.1145/1837853.1693472">Zhang, Cohen, and Owens</a>.
The two algorithms best suited for small systems are cyclic reduction and parallel cyclic reduction.</p>
<p>The basic idea of both cyclic reduction algorithms is as follows. Let’s consider three consecutive equations corresponding to <span class="math notranslate nohighlight">\(y_{i- 1}\)</span>, <span class="math notranslate nohighlight">\(y_i\)</span>, and <span class="math notranslate nohighlight">\(y_{i+1}\)</span>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
a_{i - 1} x_{i - 2} + b_{i - 1} x_{i - 1} + c_{i - 1} x_i &amp;= y_{i - 1}, \\
a_i x_{i - 1} + b_i x_i + c_i x_{i + 1} &amp;= y_i, \\
a_{i + 1} x_{i} + b_{i + 1} x_{i + 1} + c_{i + 1} x_{i + 2} &amp;= y_{i + 1}.
\end{aligned}
\end{split}\]</div>

We can eliminate <span class="math notranslate nohighlight">\(x_{i - 1}\)</span> and <span class="math notranslate nohighlight">\(x_{i + 1}\)</span> to obtain a system of the form
<div class="math notranslate nohighlight">
\[
\hat{a}_i x_{i - 2} + \hat{b}_i x_i + \hat{c}_i x_{i + 2} = \hat{y}_i,
\]</div>

where the modified coefficients <span class="math notranslate nohighlight">\(\hat{a}_i\)</span>, <span class="math notranslate nohighlight">\(\hat{b}_i\)</span>, <span class="math notranslate nohighlight">\(\hat{c}_i\)</span> and the modified rhs <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> are
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\hat{a}_i &amp;= -\frac{a_{i - 1} a_i}{b_{i - 1}}, \\
\hat{b}_i &amp;= b_i - \frac{c_{i - 1} a_i}{b_{i - 1}} - \frac{c_{i} a_{i + 1}}{b_{i + 1}}, \\
\hat{c}_i &amp;= -\frac{c_i c_{i + 1}}{b_{i + 1}}, \\
\hat{y}_i &amp;= y_i - \frac{a_i y_{i - 1}}{b_{i - 1}} - \frac{c_i y_{i + 1}}{b_{i + 1}}.
\end{aligned}
\end{split}\]</div>

The resulting system of equations for <span class="math notranslate nohighlight">\(x_{2j}\)</span> is still tridiagonal and has roughly half the size of the original.</p>
<p>The cyclic reduction algorithm has two phases.
In the first phase, the above elimination step is iterated until the system is reduced to either one or two equations, which can then be directly solved.
In each iteration the computation of modified coefficients can be done in parallel.
The second phase involves finding the rest of the solution by using the final coefficients.
The second phase is also iterative, where at each iteration the number of know solution values increases by a factor of two. A drawback of this algorithm is that the amount of parallel computations available at each iteration is not constant.</p>
<p>The parallel cyclic reduction is based on the same idea, but has only one phase. In the first iteration it reduces the
original system to two systems of half the size. The second iteration reduces it to four systems of quarter the size
and so on. In the final iteration systems of size one or two are solved to obtain the whole solution at once.
In contrast to the cyclic reduction, this algorithm has constant amount of parallelism available at the cost of performing
more redundant work.</p>
<p>A naive application of the cyclic reduction to the diffusion system would result
in the following equation for the modified main diagonal
<div class="math notranslate nohighlight">
\[
\hat{b}_i = h_i
             + g_{i - 1} - \frac{g_{i-1}^2}{h_{i - 1} + g_{i - 2} + g_{i - 1}}
             + g_i - \frac{g_i^2}{h_{i + 1} + g_{i} + g_{i + 1}}.
\]</div>

Using this expression can potentially result in catastrophic cancellation errors and overflows if
<span class="math notranslate nohighlight">\(g_{i - 1}\)</span> or <span class="math notranslate nohighlight">\(g_{i + 1}\)</span> are very large.
To improve its stability, this expression can be rewritten as
<div class="math notranslate nohighlight">
\[
\hat{b}_i = h_i
             + h_{i - 1} \frac{g_{i - 1}}{h_{i - 1} + g_{i - 2} + g_{i - 1}}
             + h_{i + 1} \frac{g_i}{h_{i + 1} + g_i + g_{i + 1}}
             + g_{i - 1} \frac{g_{i - 2}}{h_{i - 1} + g_{i - 2} + g_{i - 1}}
             + g_{i + 1} \frac{g_i}{h_{i + 1} + g_i + g_{i + 1}}.
\]</div>

This equation can be shown to be in the form
<div class="math notranslate nohighlight">
\[
\hat{b}_i = \hat{h}_i + \hat{g}_{i - 2} + \hat{g}_i,
\]</div>

where
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\hat{h}_i &amp;= h_i
             + h_{i - 1} \frac{g_{i - 1}}{h_{i - 1} + g_{i - 2} + g_{i - 1}}
             + h_{i + 1} \frac{g_i}{h_{i + 1} + g_i + g_{i + 1}}, \\
\hat{g}_i &amp;= g_{i + 1} \frac{g_i}{h_{i + 1} + g_i + g_{i + 1}}.
\end{aligned}
\end{split}\]</div>

These two equations form the basis of stable (parallel) cyclic reduction for diffusion problems.</p>
</section>
</section>
<section id="design">
<h2>4 Design<a class="headerlink" href="#design" title="Permalink to this heading"></a></h2>
<p>Four different algorithms will be implemented:</p>
<ul class="simple">
<li><p>Thomas algorithm for general tridiagonal systems on CPUs</p></li>
<li><p>PCR algorithm for general tridiagonal systems on GPUs</p></li>
<li><p>Thomas algorithm for diffusion systems with improved stability properties on CPUs</p></li>
<li><p>PCR algorithm for diffusion systems with improved stability properties on GPUs</p></li>
</ul>
<p>The algorithms will be designed to work within Kokkos team policies, with each team of threads
solving one column system on GPUs and <code class="docutils literal notranslate"><span class="pre">VecLength</span></code> column systems on CPUs.
The user interface for CPU and GPU solvers will be the same. There will be
two type aliases <code class="docutils literal notranslate"><span class="pre">TriDiagSolver</span></code> and <code class="docutils literal notranslate"><span class="pre">TriDiagDiffSolver</span></code> that will resolve to the
optimal solver class based on the chosen architecture.</p>
<section id="data-types-and-parameters">
<h3>4.1 Data types and parameters<a class="headerlink" href="#data-types-and-parameters" title="Permalink to this heading"></a></h3>
<section id="parameters">
<h4>4.1.1 Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h4>
<p>No parameters are required.</p>
</section>
<section id="class-structs-data-types">
<h4>4.1.2 Class/structs/data types<a class="headerlink" href="#class-structs-data-types" title="Permalink to this heading"></a></h4>
<p>There will be a solver struct for each algorithm. The solvers inputs and outputs will be encapsulated in
two scratch data structs, one for the general solver and one for the diffusion solver.</p>
</section>
<section id="scratch-data-structs">
<h4>4.1.2.1 Scratch data structs<a class="headerlink" href="#scratch-data-structs" title="Permalink to this heading"></a></h4>
<p>To facilitate constructing the systems on the fly and for performance reasons the solver inputs and outputs will be using the Kokkos scratch memory space. The scratch data for the general tridiagonal solver will be encapsulated in a struct called <code class="docutils literal notranslate"><span class="pre">TriDiagScratch</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">TriDiagScratch</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">DL</span><span class="p">;</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">DU</span><span class="p">;</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">DL</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">DU</span></code>, <code class="docutils literal notranslate"><span class="pre">X</span></code> are views of size (<code class="docutils literal notranslate"><span class="pre">NRow</span></code>, <code class="docutils literal notranslate"><span class="pre">VecLength</span></code>) in the scratch memory space. The views
<code class="docutils literal notranslate"><span class="pre">DL</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">DU</span></code> are inputs denoting the lower, main, and upper diagonal, respectively. The view <code class="docutils literal notranslate"><span class="pre">X</span></code> should contain
the rhs at input and will be overwritten with the solution after <code class="docutils literal notranslate"><span class="pre">solve</span></code> is called.</p>
<p>The scratch data for the specialized diffusion tridiagonal solver will be encapsulated in a struct called <code class="docutils literal notranslate"><span class="pre">TriDiagDiffScratch</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">TriDiagDiffScratch</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">G</span><span class="p">;</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">H</span><span class="p">;</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="w">   </span><span class="n">ScratchArray2DReal</span><span class="w"> </span><span class="n">Alpha</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">G</span></code>, <code class="docutils literal notranslate"><span class="pre">H</span></code>, <code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">Alpha</span></code> are views of size (<code class="docutils literal notranslate"><span class="pre">NRow</span></code>, <code class="docutils literal notranslate"><span class="pre">VecLength</span></code>) in the scratch memory space. The views
<code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> are inputs corresponding to the variables <code class="docutils literal notranslate"><span class="pre">g</span></code> and <code class="docutils literal notranslate"><span class="pre">h</span></code> introduced in <a class="reference internal" href="#algorithmic-formulation">Section 3</a>.
The view <code class="docutils literal notranslate"><span class="pre">X</span></code> has the same meaning as in the general case.
The view <code class="docutils literal notranslate"><span class="pre">Alpha</span></code> is an internal workspace used by the algorithm.</p>
</section>
<section id="solver-structs">
<h4>4.1.2.2 Solver structs<a class="headerlink" href="#solver-structs" title="Permalink to this heading"></a></h4>
<p>The four solver algorithms will be implemented as four structs <code class="docutils literal notranslate"><span class="pre">ThomasSolver</span></code>, <code class="docutils literal notranslate"><span class="pre">PCRSolver</span></code>, <code class="docutils literal notranslate"><span class="pre">ThomasDiffusionSolver</span></code>, and <code class="docutils literal notranslate"><span class="pre">PCRDiffusionSolver</span></code>. Currently, there is no plan for those structs to have any data members and they will only provide static methods, acting essentially as namespaces.</p>
</section>
</section>
<section id="methods">
<h3>4.2 Methods<a class="headerlink" href="#methods" title="Permalink to this heading"></a></h3>
<section id="scratch-constructors">
<h4>4.2.1 Scratch Constructors<a class="headerlink" href="#scratch-constructors" title="Permalink to this heading"></a></h4>
<p>The constructors of scratch spaces take a team member and system size (<code class="docutils literal notranslate"><span class="pre">NRow</span></code>)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">TriDiagScratch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span>
<span class="w">    </span><span class="n">TriDiagDiffScratch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="policy-creation">
<h4>4.2.2 Policy creation<a class="headerlink" href="#policy-creation" title="Permalink to this heading"></a></h4>
<p>Every solver will provide a static method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="n">TeamPolicy</span><span class="w"> </span><span class="nf">makeTeamPolicy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">NBatch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NRow</span><span class="p">);</span>
</pre></div>
</div>
<p>that creates an appropriate team policy for solving <code class="docutils literal notranslate"><span class="pre">NBatch</span></code> systems of size <code class="docutils literal notranslate"><span class="pre">NRow</span></code>.</p>
</section>
<section id="solve-methods">
<h4>4.2.3 Solve Methods<a class="headerlink" href="#solve-methods" title="Permalink to this heading"></a></h4>
<p>The general solvers <code class="docutils literal notranslate"><span class="pre">ThomasSolver</span></code> and <code class="docutils literal notranslate"><span class="pre">PCRSolver</span></code> will have a static solve method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TriDiagScratch</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Scratch</span><span class="p">);</span>
</pre></div>
</div>
<p>that takes a team member and an initialized general scratch space. After calling this method <code class="docutils literal notranslate"><span class="pre">Scratch.X</span></code>
will contain the solution. There will also be a convenience method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Member</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DL</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DU</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">X</span><span class="p">);</span>
</pre></div>
</div>
<p>that loads the inputs from global arrays.</p>
<p>The diffusion solvers <code class="docutils literal notranslate"><span class="pre">ThomasDiffusionSolver</span></code> and <code class="docutils literal notranslate"><span class="pre">PCRDiffusionSolver</span></code> will provide a similar method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Member</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TriDiagDiffScratch</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Scratch</span><span class="p">);</span>
</pre></div>
</div>
<p>differing only in the type of scratch space. Similarly, there will be a convenience method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TeamMember</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Member</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Array2DReal</span><span class="w"> </span><span class="o">&amp;</span><span class="n">X</span><span class="p">);</span>
</pre></div>
</div>
<p>which loads the inputs from global arrays.</p>
</section>
</section>
</section>
<section id="verification-and-testing">
<h2>5 Verification and Testing<a class="headerlink" href="#verification-and-testing" title="Permalink to this heading"></a></h2>
<section id="test-solvers-correctness-using-prescribed-matrix">
<h3>5.1 Test solvers correctness using prescribed matrix<a class="headerlink" href="#test-solvers-correctness-using-prescribed-matrix" title="Permalink to this heading"></a></h3>
<p>Given analytically prescribed matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> and vector <code class="docutils literal notranslate"><span class="pre">y</span></code> the solution to the problem <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">z</span></code> with <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">y</span></code> will be
checked to see if the resulting <code class="docutils literal notranslate"><span class="pre">x</span></code> is equal to the prescribed vector <code class="docutils literal notranslate"><span class="pre">y</span></code>. This will be done for all solvers for a variety of (batch size, system size) combinations.</p>
</section>
<section id="test-diffusion-solvers-convergence-using-manufactured-solution">
<h3>5.2 Test diffusion solvers convergence using manufactured solution<a class="headerlink" href="#test-diffusion-solvers-convergence-using-manufactured-solution" title="Permalink to this heading"></a></h3>
<p>The convergence of diffusion solvers will be tested using a manufactured solution.</p>
</section>
<section id="test-stability">
<h3>5.3 Test stability<a class="headerlink" href="#test-stability" title="Permalink to this heading"></a></h3>
<p>The diffusion solvers stability will be tested on an idealized vertical mixing problem with abrupt changes in
the diffusion coefficient.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Tracers.html" class="btn btn-neutral float-left" title="Tracer Infrastructure" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="VerticalMixingCoeff.html" class="btn btn-neutral float-right" title="Vertical Mixing Coefficients" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Energy Exascale Earth System Model Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>